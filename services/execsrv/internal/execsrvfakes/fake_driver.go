// Code generated by counterfeiter. DO NOT EDIT.
package execsrvfakes

import (
	"context"
	"sync"

	"github.com/unweave/unweave-v1/api/types"
	"github.com/unweave/unweave-v1/services/execsrv"
)

type FakeDriver struct {
	ExecConnectionInfoStub        func(context.Context, string) (types.ConnectionInfo, error)
	execConnectionInfoMutex       sync.RWMutex
	execConnectionInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execConnectionInfoReturns struct {
		result1 types.ConnectionInfo
		result2 error
	}
	execConnectionInfoReturnsOnCall map[int]struct {
		result1 types.ConnectionInfo
		result2 error
	}
	ExecCreateStub        func(context.Context, string, string, types.HardwareSpec, types.ExecNetwork, []types.ExecVolume, []string, *string) (string, error)
	execCreateMutex       sync.RWMutex
	execCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 types.HardwareSpec
		arg5 types.ExecNetwork
		arg6 []types.ExecVolume
		arg7 []string
		arg8 *string
	}
	execCreateReturns struct {
		result1 string
		result2 error
	}
	execCreateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExecDriverNameStub        func() string
	execDriverNameMutex       sync.RWMutex
	execDriverNameArgsForCall []struct {
	}
	execDriverNameReturns struct {
		result1 string
	}
	execDriverNameReturnsOnCall map[int]struct {
		result1 string
	}
	ExecGetStatusStub        func(context.Context, string) (types.Status, error)
	execGetStatusMutex       sync.RWMutex
	execGetStatusArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execGetStatusReturns struct {
		result1 types.Status
		result2 error
	}
	execGetStatusReturnsOnCall map[int]struct {
		result1 types.Status
		result2 error
	}
	ExecPingStub        func(context.Context, *string) error
	execPingMutex       sync.RWMutex
	execPingArgsForCall []struct {
		arg1 context.Context
		arg2 *string
	}
	execPingReturns struct {
		result1 error
	}
	execPingReturnsOnCall map[int]struct {
		result1 error
	}
	ExecProviderStub        func() types.Provider
	execProviderMutex       sync.RWMutex
	execProviderArgsForCall []struct {
	}
	execProviderReturns struct {
		result1 types.Provider
	}
	execProviderReturnsOnCall map[int]struct {
		result1 types.Provider
	}
	ExecSpecStub        func(context.Context, string) (types.HardwareSpec, error)
	execSpecMutex       sync.RWMutex
	execSpecArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execSpecReturns struct {
		result1 types.HardwareSpec
		result2 error
	}
	execSpecReturnsOnCall map[int]struct {
		result1 types.HardwareSpec
		result2 error
	}
	ExecStatsStub        func(context.Context, string) (execsrv.Stats, error)
	execStatsMutex       sync.RWMutex
	execStatsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execStatsReturns struct {
		result1 execsrv.Stats
		result2 error
	}
	execStatsReturnsOnCall map[int]struct {
		result1 execsrv.Stats
		result2 error
	}
	ExecTerminateStub        func(context.Context, string) error
	execTerminateMutex       sync.RWMutex
	execTerminateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execTerminateReturns struct {
		result1 error
	}
	execTerminateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDriver) ExecConnectionInfo(arg1 context.Context, arg2 string) (types.ConnectionInfo, error) {
	fake.execConnectionInfoMutex.Lock()
	ret, specificReturn := fake.execConnectionInfoReturnsOnCall[len(fake.execConnectionInfoArgsForCall)]
	fake.execConnectionInfoArgsForCall = append(fake.execConnectionInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecConnectionInfoStub
	fakeReturns := fake.execConnectionInfoReturns
	fake.recordInvocation("ExecConnectionInfo", []interface{}{arg1, arg2})
	fake.execConnectionInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDriver) ExecConnectionInfoCallCount() int {
	fake.execConnectionInfoMutex.RLock()
	defer fake.execConnectionInfoMutex.RUnlock()
	return len(fake.execConnectionInfoArgsForCall)
}

func (fake *FakeDriver) ExecConnectionInfoCalls(stub func(context.Context, string) (types.ConnectionInfo, error)) {
	fake.execConnectionInfoMutex.Lock()
	defer fake.execConnectionInfoMutex.Unlock()
	fake.ExecConnectionInfoStub = stub
}

func (fake *FakeDriver) ExecConnectionInfoArgsForCall(i int) (context.Context, string) {
	fake.execConnectionInfoMutex.RLock()
	defer fake.execConnectionInfoMutex.RUnlock()
	argsForCall := fake.execConnectionInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecConnectionInfoReturns(result1 types.ConnectionInfo, result2 error) {
	fake.execConnectionInfoMutex.Lock()
	defer fake.execConnectionInfoMutex.Unlock()
	fake.ExecConnectionInfoStub = nil
	fake.execConnectionInfoReturns = struct {
		result1 types.ConnectionInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecConnectionInfoReturnsOnCall(i int, result1 types.ConnectionInfo, result2 error) {
	fake.execConnectionInfoMutex.Lock()
	defer fake.execConnectionInfoMutex.Unlock()
	fake.ExecConnectionInfoStub = nil
	if fake.execConnectionInfoReturnsOnCall == nil {
		fake.execConnectionInfoReturnsOnCall = make(map[int]struct {
			result1 types.ConnectionInfo
			result2 error
		})
	}
	fake.execConnectionInfoReturnsOnCall[i] = struct {
		result1 types.ConnectionInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecCreate(arg1 context.Context, arg2 string, arg3 string, arg4 types.HardwareSpec, arg5 types.ExecNetwork, arg6 []types.ExecVolume, arg7 []string, arg8 *string) (string, error) {
	var arg6Copy []types.ExecVolume
	if arg6 != nil {
		arg6Copy = make([]types.ExecVolume, len(arg6))
		copy(arg6Copy, arg6)
	}
	var arg7Copy []string
	if arg7 != nil {
		arg7Copy = make([]string, len(arg7))
		copy(arg7Copy, arg7)
	}
	fake.execCreateMutex.Lock()
	ret, specificReturn := fake.execCreateReturnsOnCall[len(fake.execCreateArgsForCall)]
	fake.execCreateArgsForCall = append(fake.execCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 types.HardwareSpec
		arg5 types.ExecNetwork
		arg6 []types.ExecVolume
		arg7 []string
		arg8 *string
	}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7Copy, arg8})
	stub := fake.ExecCreateStub
	fakeReturns := fake.execCreateReturns
	fake.recordInvocation("ExecCreate", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7Copy, arg8})
	fake.execCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDriver) ExecCreateCallCount() int {
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	return len(fake.execCreateArgsForCall)
}

func (fake *FakeDriver) ExecCreateCalls(stub func(context.Context, string, string, types.HardwareSpec, types.ExecNetwork, []types.ExecVolume, []string, *string) (string, error)) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = stub
}

func (fake *FakeDriver) ExecCreateArgsForCall(i int) (context.Context, string, string, types.HardwareSpec, types.ExecNetwork, []types.ExecVolume, []string, *string) {
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	argsForCall := fake.execCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeDriver) ExecCreateReturns(result1 string, result2 error) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = nil
	fake.execCreateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecCreateReturnsOnCall(i int, result1 string, result2 error) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = nil
	if fake.execCreateReturnsOnCall == nil {
		fake.execCreateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.execCreateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecDriverName() string {
	fake.execDriverNameMutex.Lock()
	ret, specificReturn := fake.execDriverNameReturnsOnCall[len(fake.execDriverNameArgsForCall)]
	fake.execDriverNameArgsForCall = append(fake.execDriverNameArgsForCall, struct {
	}{})
	stub := fake.ExecDriverNameStub
	fakeReturns := fake.execDriverNameReturns
	fake.recordInvocation("ExecDriverName", []interface{}{})
	fake.execDriverNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDriver) ExecDriverNameCallCount() int {
	fake.execDriverNameMutex.RLock()
	defer fake.execDriverNameMutex.RUnlock()
	return len(fake.execDriverNameArgsForCall)
}

func (fake *FakeDriver) ExecDriverNameCalls(stub func() string) {
	fake.execDriverNameMutex.Lock()
	defer fake.execDriverNameMutex.Unlock()
	fake.ExecDriverNameStub = stub
}

func (fake *FakeDriver) ExecDriverNameReturns(result1 string) {
	fake.execDriverNameMutex.Lock()
	defer fake.execDriverNameMutex.Unlock()
	fake.ExecDriverNameStub = nil
	fake.execDriverNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDriver) ExecDriverNameReturnsOnCall(i int, result1 string) {
	fake.execDriverNameMutex.Lock()
	defer fake.execDriverNameMutex.Unlock()
	fake.ExecDriverNameStub = nil
	if fake.execDriverNameReturnsOnCall == nil {
		fake.execDriverNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.execDriverNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeDriver) ExecGetStatus(arg1 context.Context, arg2 string) (types.Status, error) {
	fake.execGetStatusMutex.Lock()
	ret, specificReturn := fake.execGetStatusReturnsOnCall[len(fake.execGetStatusArgsForCall)]
	fake.execGetStatusArgsForCall = append(fake.execGetStatusArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecGetStatusStub
	fakeReturns := fake.execGetStatusReturns
	fake.recordInvocation("ExecGetStatus", []interface{}{arg1, arg2})
	fake.execGetStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDriver) ExecGetStatusCallCount() int {
	fake.execGetStatusMutex.RLock()
	defer fake.execGetStatusMutex.RUnlock()
	return len(fake.execGetStatusArgsForCall)
}

func (fake *FakeDriver) ExecGetStatusCalls(stub func(context.Context, string) (types.Status, error)) {
	fake.execGetStatusMutex.Lock()
	defer fake.execGetStatusMutex.Unlock()
	fake.ExecGetStatusStub = stub
}

func (fake *FakeDriver) ExecGetStatusArgsForCall(i int) (context.Context, string) {
	fake.execGetStatusMutex.RLock()
	defer fake.execGetStatusMutex.RUnlock()
	argsForCall := fake.execGetStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecGetStatusReturns(result1 types.Status, result2 error) {
	fake.execGetStatusMutex.Lock()
	defer fake.execGetStatusMutex.Unlock()
	fake.ExecGetStatusStub = nil
	fake.execGetStatusReturns = struct {
		result1 types.Status
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecGetStatusReturnsOnCall(i int, result1 types.Status, result2 error) {
	fake.execGetStatusMutex.Lock()
	defer fake.execGetStatusMutex.Unlock()
	fake.ExecGetStatusStub = nil
	if fake.execGetStatusReturnsOnCall == nil {
		fake.execGetStatusReturnsOnCall = make(map[int]struct {
			result1 types.Status
			result2 error
		})
	}
	fake.execGetStatusReturnsOnCall[i] = struct {
		result1 types.Status
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecPing(arg1 context.Context, arg2 *string) error {
	fake.execPingMutex.Lock()
	ret, specificReturn := fake.execPingReturnsOnCall[len(fake.execPingArgsForCall)]
	fake.execPingArgsForCall = append(fake.execPingArgsForCall, struct {
		arg1 context.Context
		arg2 *string
	}{arg1, arg2})
	stub := fake.ExecPingStub
	fakeReturns := fake.execPingReturns
	fake.recordInvocation("ExecPing", []interface{}{arg1, arg2})
	fake.execPingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDriver) ExecPingCallCount() int {
	fake.execPingMutex.RLock()
	defer fake.execPingMutex.RUnlock()
	return len(fake.execPingArgsForCall)
}

func (fake *FakeDriver) ExecPingCalls(stub func(context.Context, *string) error) {
	fake.execPingMutex.Lock()
	defer fake.execPingMutex.Unlock()
	fake.ExecPingStub = stub
}

func (fake *FakeDriver) ExecPingArgsForCall(i int) (context.Context, *string) {
	fake.execPingMutex.RLock()
	defer fake.execPingMutex.RUnlock()
	argsForCall := fake.execPingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecPingReturns(result1 error) {
	fake.execPingMutex.Lock()
	defer fake.execPingMutex.Unlock()
	fake.ExecPingStub = nil
	fake.execPingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDriver) ExecPingReturnsOnCall(i int, result1 error) {
	fake.execPingMutex.Lock()
	defer fake.execPingMutex.Unlock()
	fake.ExecPingStub = nil
	if fake.execPingReturnsOnCall == nil {
		fake.execPingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execPingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDriver) ExecProvider() types.Provider {
	fake.execProviderMutex.Lock()
	ret, specificReturn := fake.execProviderReturnsOnCall[len(fake.execProviderArgsForCall)]
	fake.execProviderArgsForCall = append(fake.execProviderArgsForCall, struct {
	}{})
	stub := fake.ExecProviderStub
	fakeReturns := fake.execProviderReturns
	fake.recordInvocation("ExecProvider", []interface{}{})
	fake.execProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDriver) ExecProviderCallCount() int {
	fake.execProviderMutex.RLock()
	defer fake.execProviderMutex.RUnlock()
	return len(fake.execProviderArgsForCall)
}

func (fake *FakeDriver) ExecProviderCalls(stub func() types.Provider) {
	fake.execProviderMutex.Lock()
	defer fake.execProviderMutex.Unlock()
	fake.ExecProviderStub = stub
}

func (fake *FakeDriver) ExecProviderReturns(result1 types.Provider) {
	fake.execProviderMutex.Lock()
	defer fake.execProviderMutex.Unlock()
	fake.ExecProviderStub = nil
	fake.execProviderReturns = struct {
		result1 types.Provider
	}{result1}
}

func (fake *FakeDriver) ExecProviderReturnsOnCall(i int, result1 types.Provider) {
	fake.execProviderMutex.Lock()
	defer fake.execProviderMutex.Unlock()
	fake.ExecProviderStub = nil
	if fake.execProviderReturnsOnCall == nil {
		fake.execProviderReturnsOnCall = make(map[int]struct {
			result1 types.Provider
		})
	}
	fake.execProviderReturnsOnCall[i] = struct {
		result1 types.Provider
	}{result1}
}

func (fake *FakeDriver) ExecSpec(arg1 context.Context, arg2 string) (types.HardwareSpec, error) {
	fake.execSpecMutex.Lock()
	ret, specificReturn := fake.execSpecReturnsOnCall[len(fake.execSpecArgsForCall)]
	fake.execSpecArgsForCall = append(fake.execSpecArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecSpecStub
	fakeReturns := fake.execSpecReturns
	fake.recordInvocation("ExecSpec", []interface{}{arg1, arg2})
	fake.execSpecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDriver) ExecSpecCallCount() int {
	fake.execSpecMutex.RLock()
	defer fake.execSpecMutex.RUnlock()
	return len(fake.execSpecArgsForCall)
}

func (fake *FakeDriver) ExecSpecCalls(stub func(context.Context, string) (types.HardwareSpec, error)) {
	fake.execSpecMutex.Lock()
	defer fake.execSpecMutex.Unlock()
	fake.ExecSpecStub = stub
}

func (fake *FakeDriver) ExecSpecArgsForCall(i int) (context.Context, string) {
	fake.execSpecMutex.RLock()
	defer fake.execSpecMutex.RUnlock()
	argsForCall := fake.execSpecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecSpecReturns(result1 types.HardwareSpec, result2 error) {
	fake.execSpecMutex.Lock()
	defer fake.execSpecMutex.Unlock()
	fake.ExecSpecStub = nil
	fake.execSpecReturns = struct {
		result1 types.HardwareSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecSpecReturnsOnCall(i int, result1 types.HardwareSpec, result2 error) {
	fake.execSpecMutex.Lock()
	defer fake.execSpecMutex.Unlock()
	fake.ExecSpecStub = nil
	if fake.execSpecReturnsOnCall == nil {
		fake.execSpecReturnsOnCall = make(map[int]struct {
			result1 types.HardwareSpec
			result2 error
		})
	}
	fake.execSpecReturnsOnCall[i] = struct {
		result1 types.HardwareSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecStats(arg1 context.Context, arg2 string) (execsrv.Stats, error) {
	fake.execStatsMutex.Lock()
	ret, specificReturn := fake.execStatsReturnsOnCall[len(fake.execStatsArgsForCall)]
	fake.execStatsArgsForCall = append(fake.execStatsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecStatsStub
	fakeReturns := fake.execStatsReturns
	fake.recordInvocation("ExecStats", []interface{}{arg1, arg2})
	fake.execStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDriver) ExecStatsCallCount() int {
	fake.execStatsMutex.RLock()
	defer fake.execStatsMutex.RUnlock()
	return len(fake.execStatsArgsForCall)
}

func (fake *FakeDriver) ExecStatsCalls(stub func(context.Context, string) (execsrv.Stats, error)) {
	fake.execStatsMutex.Lock()
	defer fake.execStatsMutex.Unlock()
	fake.ExecStatsStub = stub
}

func (fake *FakeDriver) ExecStatsArgsForCall(i int) (context.Context, string) {
	fake.execStatsMutex.RLock()
	defer fake.execStatsMutex.RUnlock()
	argsForCall := fake.execStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecStatsReturns(result1 execsrv.Stats, result2 error) {
	fake.execStatsMutex.Lock()
	defer fake.execStatsMutex.Unlock()
	fake.ExecStatsStub = nil
	fake.execStatsReturns = struct {
		result1 execsrv.Stats
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecStatsReturnsOnCall(i int, result1 execsrv.Stats, result2 error) {
	fake.execStatsMutex.Lock()
	defer fake.execStatsMutex.Unlock()
	fake.ExecStatsStub = nil
	if fake.execStatsReturnsOnCall == nil {
		fake.execStatsReturnsOnCall = make(map[int]struct {
			result1 execsrv.Stats
			result2 error
		})
	}
	fake.execStatsReturnsOnCall[i] = struct {
		result1 execsrv.Stats
		result2 error
	}{result1, result2}
}

func (fake *FakeDriver) ExecTerminate(arg1 context.Context, arg2 string) error {
	fake.execTerminateMutex.Lock()
	ret, specificReturn := fake.execTerminateReturnsOnCall[len(fake.execTerminateArgsForCall)]
	fake.execTerminateArgsForCall = append(fake.execTerminateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecTerminateStub
	fakeReturns := fake.execTerminateReturns
	fake.recordInvocation("ExecTerminate", []interface{}{arg1, arg2})
	fake.execTerminateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDriver) ExecTerminateCallCount() int {
	fake.execTerminateMutex.RLock()
	defer fake.execTerminateMutex.RUnlock()
	return len(fake.execTerminateArgsForCall)
}

func (fake *FakeDriver) ExecTerminateCalls(stub func(context.Context, string) error) {
	fake.execTerminateMutex.Lock()
	defer fake.execTerminateMutex.Unlock()
	fake.ExecTerminateStub = stub
}

func (fake *FakeDriver) ExecTerminateArgsForCall(i int) (context.Context, string) {
	fake.execTerminateMutex.RLock()
	defer fake.execTerminateMutex.RUnlock()
	argsForCall := fake.execTerminateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDriver) ExecTerminateReturns(result1 error) {
	fake.execTerminateMutex.Lock()
	defer fake.execTerminateMutex.Unlock()
	fake.ExecTerminateStub = nil
	fake.execTerminateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDriver) ExecTerminateReturnsOnCall(i int, result1 error) {
	fake.execTerminateMutex.Lock()
	defer fake.execTerminateMutex.Unlock()
	fake.ExecTerminateStub = nil
	if fake.execTerminateReturnsOnCall == nil {
		fake.execTerminateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execTerminateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDriver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.execConnectionInfoMutex.RLock()
	defer fake.execConnectionInfoMutex.RUnlock()
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	fake.execDriverNameMutex.RLock()
	defer fake.execDriverNameMutex.RUnlock()
	fake.execGetStatusMutex.RLock()
	defer fake.execGetStatusMutex.RUnlock()
	fake.execPingMutex.RLock()
	defer fake.execPingMutex.RUnlock()
	fake.execProviderMutex.RLock()
	defer fake.execProviderMutex.RUnlock()
	fake.execSpecMutex.RLock()
	defer fake.execSpecMutex.RUnlock()
	fake.execStatsMutex.RLock()
	defer fake.execStatsMutex.RUnlock()
	fake.execTerminateMutex.RLock()
	defer fake.execTerminateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDriver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ execsrv.Driver = new(FakeDriver)
