// Code generated by counterfeiter. DO NOT EDIT.
package execsrvfakes

import (
	"context"
	"sync"

	"github.com/unweave/unweave/db"
)

type FakeQuerier struct {
	BuildCreateStub        func(context.Context, db.BuildCreateParams) (string, error)
	buildCreateMutex       sync.RWMutex
	buildCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.BuildCreateParams
	}
	buildCreateReturns struct {
		result1 string
		result2 error
	}
	buildCreateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	BuildGetStub        func(context.Context, string) (db.UnweaveBuild, error)
	buildGetMutex       sync.RWMutex
	buildGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	buildGetReturns struct {
		result1 db.UnweaveBuild
		result2 error
	}
	buildGetReturnsOnCall map[int]struct {
		result1 db.UnweaveBuild
		result2 error
	}
	BuildGetUsedByStub        func(context.Context, string) ([]db.BuildGetUsedByRow, error)
	buildGetUsedByMutex       sync.RWMutex
	buildGetUsedByArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	buildGetUsedByReturns struct {
		result1 []db.BuildGetUsedByRow
		result2 error
	}
	buildGetUsedByReturnsOnCall map[int]struct {
		result1 []db.BuildGetUsedByRow
		result2 error
	}
	BuildUpdateStub        func(context.Context, db.BuildUpdateParams) error
	buildUpdateMutex       sync.RWMutex
	buildUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 db.BuildUpdateParams
	}
	buildUpdateReturns struct {
		result1 error
	}
	buildUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointCheckStub        func(context.Context, string) (db.UnweaveEndpointCheck, error)
	endpointCheckMutex       sync.RWMutex
	endpointCheckArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointCheckReturns struct {
		result1 db.UnweaveEndpointCheck
		result2 error
	}
	endpointCheckReturnsOnCall map[int]struct {
		result1 db.UnweaveEndpointCheck
		result2 error
	}
	EndpointCheckCreateStub        func(context.Context, db.EndpointCheckCreateParams) error
	endpointCheckCreateMutex       sync.RWMutex
	endpointCheckCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointCheckCreateParams
	}
	endpointCheckCreateReturns struct {
		result1 error
	}
	endpointCheckCreateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointCheckStepCreateStub        func(context.Context, db.EndpointCheckStepCreateParams) error
	endpointCheckStepCreateMutex       sync.RWMutex
	endpointCheckStepCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointCheckStepCreateParams
	}
	endpointCheckStepCreateReturns struct {
		result1 error
	}
	endpointCheckStepCreateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointCheckStepUpdateStub        func(context.Context, db.EndpointCheckStepUpdateParams) error
	endpointCheckStepUpdateMutex       sync.RWMutex
	endpointCheckStepUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointCheckStepUpdateParams
	}
	endpointCheckStepUpdateReturns struct {
		result1 error
	}
	endpointCheckStepUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointCheckStepsStub        func(context.Context, string) ([]db.UnweaveEndpointCheckStep, error)
	endpointCheckStepsMutex       sync.RWMutex
	endpointCheckStepsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointCheckStepsReturns struct {
		result1 []db.UnweaveEndpointCheckStep
		result2 error
	}
	endpointCheckStepsReturnsOnCall map[int]struct {
		result1 []db.UnweaveEndpointCheckStep
		result2 error
	}
	EndpointCreateStub        func(context.Context, db.EndpointCreateParams) error
	endpointCreateMutex       sync.RWMutex
	endpointCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointCreateParams
	}
	endpointCreateReturns struct {
		result1 error
	}
	endpointCreateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointDeleteStub        func(context.Context, string) error
	endpointDeleteMutex       sync.RWMutex
	endpointDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointDeleteReturns struct {
		result1 error
	}
	endpointDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointEvalStub        func(context.Context, string) ([]db.UnweaveEndpointEval, error)
	endpointEvalMutex       sync.RWMutex
	endpointEvalArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointEvalReturns struct {
		result1 []db.UnweaveEndpointEval
		result2 error
	}
	endpointEvalReturnsOnCall map[int]struct {
		result1 []db.UnweaveEndpointEval
		result2 error
	}
	EndpointEvalAttachStub        func(context.Context, db.EndpointEvalAttachParams) error
	endpointEvalAttachMutex       sync.RWMutex
	endpointEvalAttachArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointEvalAttachParams
	}
	endpointEvalAttachReturns struct {
		result1 error
	}
	endpointEvalAttachReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointGetStub        func(context.Context, db.EndpointGetParams) (db.UnweaveEndpoint, error)
	endpointGetMutex       sync.RWMutex
	endpointGetArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointGetParams
	}
	endpointGetReturns struct {
		result1 db.UnweaveEndpoint
		result2 error
	}
	endpointGetReturnsOnCall map[int]struct {
		result1 db.UnweaveEndpoint
		result2 error
	}
	EndpointVersionStub        func(context.Context, string) (db.UnweaveEndpointVersion, error)
	endpointVersionMutex       sync.RWMutex
	endpointVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointVersionReturns struct {
		result1 db.UnweaveEndpointVersion
		result2 error
	}
	endpointVersionReturnsOnCall map[int]struct {
		result1 db.UnweaveEndpointVersion
		result2 error
	}
	EndpointVersionCreateStub        func(context.Context, db.EndpointVersionCreateParams) error
	endpointVersionCreateMutex       sync.RWMutex
	endpointVersionCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EndpointVersionCreateParams
	}
	endpointVersionCreateReturns struct {
		result1 error
	}
	endpointVersionCreateReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointVersionDemoteStub        func(context.Context, string) error
	endpointVersionDemoteMutex       sync.RWMutex
	endpointVersionDemoteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointVersionDemoteReturns struct {
		result1 error
	}
	endpointVersionDemoteReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointVersionListStub        func(context.Context, string) ([]db.UnweaveEndpointVersion, error)
	endpointVersionListMutex       sync.RWMutex
	endpointVersionListArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointVersionListReturns struct {
		result1 []db.UnweaveEndpointVersion
		result2 error
	}
	endpointVersionListReturnsOnCall map[int]struct {
		result1 []db.UnweaveEndpointVersion
		result2 error
	}
	EndpointVersionPromoteStub        func(context.Context, string) error
	endpointVersionPromoteMutex       sync.RWMutex
	endpointVersionPromoteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointVersionPromoteReturns struct {
		result1 error
	}
	endpointVersionPromoteReturnsOnCall map[int]struct {
		result1 error
	}
	EndpointsForProjectStub        func(context.Context, string) ([]db.UnweaveEndpoint, error)
	endpointsForProjectMutex       sync.RWMutex
	endpointsForProjectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	endpointsForProjectReturns struct {
		result1 []db.UnweaveEndpoint
		result2 error
	}
	endpointsForProjectReturnsOnCall map[int]struct {
		result1 []db.UnweaveEndpoint
		result2 error
	}
	EvalCreateStub        func(context.Context, db.EvalCreateParams) error
	evalCreateMutex       sync.RWMutex
	evalCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.EvalCreateParams
	}
	evalCreateReturns struct {
		result1 error
	}
	evalCreateReturnsOnCall map[int]struct {
		result1 error
	}
	EvalDeleteStub        func(context.Context, string) error
	evalDeleteMutex       sync.RWMutex
	evalDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	evalDeleteReturns struct {
		result1 error
	}
	evalDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	EvalGetStub        func(context.Context, string) (db.EvalGetRow, error)
	evalGetMutex       sync.RWMutex
	evalGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	evalGetReturns struct {
		result1 db.EvalGetRow
		result2 error
	}
	evalGetReturnsOnCall map[int]struct {
		result1 db.EvalGetRow
		result2 error
	}
	EvalListStub        func(context.Context, []string) ([]db.EvalListRow, error)
	evalListMutex       sync.RWMutex
	evalListArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	evalListReturns struct {
		result1 []db.EvalListRow
		result2 error
	}
	evalListReturnsOnCall map[int]struct {
		result1 []db.EvalListRow
		result2 error
	}
	EvalListForProjectStub        func(context.Context, string) ([]db.EvalListForProjectRow, error)
	evalListForProjectMutex       sync.RWMutex
	evalListForProjectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	evalListForProjectReturns struct {
		result1 []db.EvalListForProjectRow
		result2 error
	}
	evalListForProjectReturnsOnCall map[int]struct {
		result1 []db.EvalListForProjectRow
		result2 error
	}
	ExecCreateStub        func(context.Context, db.ExecCreateParams) error
	execCreateMutex       sync.RWMutex
	execCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecCreateParams
	}
	execCreateReturns struct {
		result1 error
	}
	execCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ExecGetStub        func(context.Context, string) (db.UnweaveExec, error)
	execGetMutex       sync.RWMutex
	execGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execGetReturns struct {
		result1 db.UnweaveExec
		result2 error
	}
	execGetReturnsOnCall map[int]struct {
		result1 db.UnweaveExec
		result2 error
	}
	ExecGetAllActiveStub        func(context.Context) ([]db.UnweaveExec, error)
	execGetAllActiveMutex       sync.RWMutex
	execGetAllActiveArgsForCall []struct {
		arg1 context.Context
	}
	execGetAllActiveReturns struct {
		result1 []db.UnweaveExec
		result2 error
	}
	execGetAllActiveReturnsOnCall map[int]struct {
		result1 []db.UnweaveExec
		result2 error
	}
	ExecListStub        func(context.Context, db.ExecListParams) ([]db.UnweaveExec, error)
	execListMutex       sync.RWMutex
	execListArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecListParams
	}
	execListReturns struct {
		result1 []db.UnweaveExec
		result2 error
	}
	execListReturnsOnCall map[int]struct {
		result1 []db.UnweaveExec
		result2 error
	}
	ExecListActiveByProviderStub        func(context.Context, string) ([]db.UnweaveExec, error)
	execListActiveByProviderMutex       sync.RWMutex
	execListActiveByProviderArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execListActiveByProviderReturns struct {
		result1 []db.UnweaveExec
		result2 error
	}
	execListActiveByProviderReturnsOnCall map[int]struct {
		result1 []db.UnweaveExec
		result2 error
	}
	ExecListByProviderStub        func(context.Context, string) ([]db.UnweaveExec, error)
	execListByProviderMutex       sync.RWMutex
	execListByProviderArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execListByProviderReturns struct {
		result1 []db.UnweaveExec
		result2 error
	}
	execListByProviderReturnsOnCall map[int]struct {
		result1 []db.UnweaveExec
		result2 error
	}
	ExecSSHKeyDeleteStub        func(context.Context, db.ExecSSHKeyDeleteParams) error
	execSSHKeyDeleteMutex       sync.RWMutex
	execSSHKeyDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyDeleteParams
	}
	execSSHKeyDeleteReturns struct {
		result1 error
	}
	execSSHKeyDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	ExecSSHKeyGetStub        func(context.Context, db.ExecSSHKeyGetParams) (db.UnweaveExecSshKey, error)
	execSSHKeyGetMutex       sync.RWMutex
	execSSHKeyGetArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyGetParams
	}
	execSSHKeyGetReturns struct {
		result1 db.UnweaveExecSshKey
		result2 error
	}
	execSSHKeyGetReturnsOnCall map[int]struct {
		result1 db.UnweaveExecSshKey
		result2 error
	}
	ExecSSHKeyInsertStub        func(context.Context, db.ExecSSHKeyInsertParams) error
	execSSHKeyInsertMutex       sync.RWMutex
	execSSHKeyInsertArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyInsertParams
	}
	execSSHKeyInsertReturns struct {
		result1 error
	}
	execSSHKeyInsertReturnsOnCall map[int]struct {
		result1 error
	}
	ExecSSHKeysGetByExecIDStub        func(context.Context, string) ([]db.UnweaveExecSshKey, error)
	execSSHKeysGetByExecIDMutex       sync.RWMutex
	execSSHKeysGetByExecIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execSSHKeysGetByExecIDReturns struct {
		result1 []db.UnweaveExecSshKey
		result2 error
	}
	execSSHKeysGetByExecIDReturnsOnCall map[int]struct {
		result1 []db.UnweaveExecSshKey
		result2 error
	}
	ExecSetErrorStub        func(context.Context, db.ExecSetErrorParams) error
	execSetErrorMutex       sync.RWMutex
	execSetErrorArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecSetErrorParams
	}
	execSetErrorReturns struct {
		result1 error
	}
	execSetErrorReturnsOnCall map[int]struct {
		result1 error
	}
	ExecSetFailedStub        func(context.Context, db.ExecSetFailedParams) error
	execSetFailedMutex       sync.RWMutex
	execSetFailedArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecSetFailedParams
	}
	execSetFailedReturns struct {
		result1 error
	}
	execSetFailedReturnsOnCall map[int]struct {
		result1 error
	}
	ExecStatusUpdateStub        func(context.Context, db.ExecStatusUpdateParams) error
	execStatusUpdateMutex       sync.RWMutex
	execStatusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecStatusUpdateParams
	}
	execStatusUpdateReturns struct {
		result1 error
	}
	execStatusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpdateConnectionInfoStub        func(context.Context, db.ExecUpdateConnectionInfoParams) error
	execUpdateConnectionInfoMutex       sync.RWMutex
	execUpdateConnectionInfoArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecUpdateConnectionInfoParams
	}
	execUpdateConnectionInfoReturns struct {
		result1 error
	}
	execUpdateConnectionInfoReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpdateNetworkStub        func(context.Context, db.ExecUpdateNetworkParams) error
	execUpdateNetworkMutex       sync.RWMutex
	execUpdateNetworkArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecUpdateNetworkParams
	}
	execUpdateNetworkReturns struct {
		result1 error
	}
	execUpdateNetworkReturnsOnCall map[int]struct {
		result1 error
	}
	ExecVolumeCreateStub        func(context.Context, db.ExecVolumeCreateParams) error
	execVolumeCreateMutex       sync.RWMutex
	execVolumeCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.ExecVolumeCreateParams
	}
	execVolumeCreateReturns struct {
		result1 error
	}
	execVolumeCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ExecVolumeDeleteStub        func(context.Context, string) error
	execVolumeDeleteMutex       sync.RWMutex
	execVolumeDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execVolumeDeleteReturns struct {
		result1 error
	}
	execVolumeDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	ExecVolumeGetStub        func(context.Context, string) ([]db.UnweaveExecVolume, error)
	execVolumeGetMutex       sync.RWMutex
	execVolumeGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	execVolumeGetReturns struct {
		result1 []db.UnweaveExecVolume
		result2 error
	}
	execVolumeGetReturnsOnCall map[int]struct {
		result1 []db.UnweaveExecVolume
		result2 error
	}
	MxExecGetStub        func(context.Context, string) (db.MxExecGetRow, error)
	mxExecGetMutex       sync.RWMutex
	mxExecGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	mxExecGetReturns struct {
		result1 db.MxExecGetRow
		result2 error
	}
	mxExecGetReturnsOnCall map[int]struct {
		result1 db.MxExecGetRow
		result2 error
	}
	MxExecsGetStub        func(context.Context, string) ([]db.MxExecsGetRow, error)
	mxExecsGetMutex       sync.RWMutex
	mxExecsGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	mxExecsGetReturns struct {
		result1 []db.MxExecsGetRow
		result2 error
	}
	mxExecsGetReturnsOnCall map[int]struct {
		result1 []db.MxExecsGetRow
		result2 error
	}
	NodeCreateStub        func(context.Context, db.NodeCreateParams) error
	nodeCreateMutex       sync.RWMutex
	nodeCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.NodeCreateParams
	}
	nodeCreateReturns struct {
		result1 error
	}
	nodeCreateReturnsOnCall map[int]struct {
		result1 error
	}
	NodeStatusUpdateStub        func(context.Context, db.NodeStatusUpdateParams) error
	nodeStatusUpdateMutex       sync.RWMutex
	nodeStatusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 db.NodeStatusUpdateParams
	}
	nodeStatusUpdateReturns struct {
		result1 error
	}
	nodeStatusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ProjectGetStub        func(context.Context, string) (db.UnweaveProject, error)
	projectGetMutex       sync.RWMutex
	projectGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	projectGetReturns struct {
		result1 db.UnweaveProject
		result2 error
	}
	projectGetReturnsOnCall map[int]struct {
		result1 db.UnweaveProject
		result2 error
	}
	SSHKeyAddStub        func(context.Context, db.SSHKeyAddParams) error
	sSHKeyAddMutex       sync.RWMutex
	sSHKeyAddArgsForCall []struct {
		arg1 context.Context
		arg2 db.SSHKeyAddParams
	}
	sSHKeyAddReturns struct {
		result1 error
	}
	sSHKeyAddReturnsOnCall map[int]struct {
		result1 error
	}
	SSHKeyGetByNameStub        func(context.Context, db.SSHKeyGetByNameParams) (db.UnweaveSshKey, error)
	sSHKeyGetByNameMutex       sync.RWMutex
	sSHKeyGetByNameArgsForCall []struct {
		arg1 context.Context
		arg2 db.SSHKeyGetByNameParams
	}
	sSHKeyGetByNameReturns struct {
		result1 db.UnweaveSshKey
		result2 error
	}
	sSHKeyGetByNameReturnsOnCall map[int]struct {
		result1 db.UnweaveSshKey
		result2 error
	}
	SSHKeyGetByPublicKeyStub        func(context.Context, db.SSHKeyGetByPublicKeyParams) (db.UnweaveSshKey, error)
	sSHKeyGetByPublicKeyMutex       sync.RWMutex
	sSHKeyGetByPublicKeyArgsForCall []struct {
		arg1 context.Context
		arg2 db.SSHKeyGetByPublicKeyParams
	}
	sSHKeyGetByPublicKeyReturns struct {
		result1 db.UnweaveSshKey
		result2 error
	}
	sSHKeyGetByPublicKeyReturnsOnCall map[int]struct {
		result1 db.UnweaveSshKey
		result2 error
	}
	SSHKeysGetStub        func(context.Context, string) ([]db.UnweaveSshKey, error)
	sSHKeysGetMutex       sync.RWMutex
	sSHKeysGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sSHKeysGetReturns struct {
		result1 []db.UnweaveSshKey
		result2 error
	}
	sSHKeysGetReturnsOnCall map[int]struct {
		result1 []db.UnweaveSshKey
		result2 error
	}
	SSHKeysGetByIDsStub        func(context.Context, []string) ([]db.UnweaveSshKey, error)
	sSHKeysGetByIDsMutex       sync.RWMutex
	sSHKeysGetByIDsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	sSHKeysGetByIDsReturns struct {
		result1 []db.UnweaveSshKey
		result2 error
	}
	sSHKeysGetByIDsReturnsOnCall map[int]struct {
		result1 []db.UnweaveSshKey
		result2 error
	}
	VolumeCreateStub        func(context.Context, db.VolumeCreateParams) (db.UnweaveVolume, error)
	volumeCreateMutex       sync.RWMutex
	volumeCreateArgsForCall []struct {
		arg1 context.Context
		arg2 db.VolumeCreateParams
	}
	volumeCreateReturns struct {
		result1 db.UnweaveVolume
		result2 error
	}
	volumeCreateReturnsOnCall map[int]struct {
		result1 db.UnweaveVolume
		result2 error
	}
	VolumeDeleteStub        func(context.Context, string) error
	volumeDeleteMutex       sync.RWMutex
	volumeDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	volumeDeleteReturns struct {
		result1 error
	}
	volumeDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	VolumeGetStub        func(context.Context, db.VolumeGetParams) (db.UnweaveVolume, error)
	volumeGetMutex       sync.RWMutex
	volumeGetArgsForCall []struct {
		arg1 context.Context
		arg2 db.VolumeGetParams
	}
	volumeGetReturns struct {
		result1 db.UnweaveVolume
		result2 error
	}
	volumeGetReturnsOnCall map[int]struct {
		result1 db.UnweaveVolume
		result2 error
	}
	VolumeListStub        func(context.Context, string) ([]db.UnweaveVolume, error)
	volumeListMutex       sync.RWMutex
	volumeListArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	volumeListReturns struct {
		result1 []db.UnweaveVolume
		result2 error
	}
	volumeListReturnsOnCall map[int]struct {
		result1 []db.UnweaveVolume
		result2 error
	}
	VolumeUpdateStub        func(context.Context, db.VolumeUpdateParams) error
	volumeUpdateMutex       sync.RWMutex
	volumeUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 db.VolumeUpdateParams
	}
	volumeUpdateReturns struct {
		result1 error
	}
	volumeUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQuerier) BuildCreate(arg1 context.Context, arg2 db.BuildCreateParams) (string, error) {
	fake.buildCreateMutex.Lock()
	ret, specificReturn := fake.buildCreateReturnsOnCall[len(fake.buildCreateArgsForCall)]
	fake.buildCreateArgsForCall = append(fake.buildCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.BuildCreateParams
	}{arg1, arg2})
	stub := fake.BuildCreateStub
	fakeReturns := fake.buildCreateReturns
	fake.recordInvocation("BuildCreate", []interface{}{arg1, arg2})
	fake.buildCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) BuildCreateCallCount() int {
	fake.buildCreateMutex.RLock()
	defer fake.buildCreateMutex.RUnlock()
	return len(fake.buildCreateArgsForCall)
}

func (fake *FakeQuerier) BuildCreateCalls(stub func(context.Context, db.BuildCreateParams) (string, error)) {
	fake.buildCreateMutex.Lock()
	defer fake.buildCreateMutex.Unlock()
	fake.BuildCreateStub = stub
}

func (fake *FakeQuerier) BuildCreateArgsForCall(i int) (context.Context, db.BuildCreateParams) {
	fake.buildCreateMutex.RLock()
	defer fake.buildCreateMutex.RUnlock()
	argsForCall := fake.buildCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) BuildCreateReturns(result1 string, result2 error) {
	fake.buildCreateMutex.Lock()
	defer fake.buildCreateMutex.Unlock()
	fake.BuildCreateStub = nil
	fake.buildCreateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildCreateReturnsOnCall(i int, result1 string, result2 error) {
	fake.buildCreateMutex.Lock()
	defer fake.buildCreateMutex.Unlock()
	fake.BuildCreateStub = nil
	if fake.buildCreateReturnsOnCall == nil {
		fake.buildCreateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.buildCreateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildGet(arg1 context.Context, arg2 string) (db.UnweaveBuild, error) {
	fake.buildGetMutex.Lock()
	ret, specificReturn := fake.buildGetReturnsOnCall[len(fake.buildGetArgsForCall)]
	fake.buildGetArgsForCall = append(fake.buildGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BuildGetStub
	fakeReturns := fake.buildGetReturns
	fake.recordInvocation("BuildGet", []interface{}{arg1, arg2})
	fake.buildGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) BuildGetCallCount() int {
	fake.buildGetMutex.RLock()
	defer fake.buildGetMutex.RUnlock()
	return len(fake.buildGetArgsForCall)
}

func (fake *FakeQuerier) BuildGetCalls(stub func(context.Context, string) (db.UnweaveBuild, error)) {
	fake.buildGetMutex.Lock()
	defer fake.buildGetMutex.Unlock()
	fake.BuildGetStub = stub
}

func (fake *FakeQuerier) BuildGetArgsForCall(i int) (context.Context, string) {
	fake.buildGetMutex.RLock()
	defer fake.buildGetMutex.RUnlock()
	argsForCall := fake.buildGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) BuildGetReturns(result1 db.UnweaveBuild, result2 error) {
	fake.buildGetMutex.Lock()
	defer fake.buildGetMutex.Unlock()
	fake.BuildGetStub = nil
	fake.buildGetReturns = struct {
		result1 db.UnweaveBuild
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildGetReturnsOnCall(i int, result1 db.UnweaveBuild, result2 error) {
	fake.buildGetMutex.Lock()
	defer fake.buildGetMutex.Unlock()
	fake.BuildGetStub = nil
	if fake.buildGetReturnsOnCall == nil {
		fake.buildGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveBuild
			result2 error
		})
	}
	fake.buildGetReturnsOnCall[i] = struct {
		result1 db.UnweaveBuild
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildGetUsedBy(arg1 context.Context, arg2 string) ([]db.BuildGetUsedByRow, error) {
	fake.buildGetUsedByMutex.Lock()
	ret, specificReturn := fake.buildGetUsedByReturnsOnCall[len(fake.buildGetUsedByArgsForCall)]
	fake.buildGetUsedByArgsForCall = append(fake.buildGetUsedByArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BuildGetUsedByStub
	fakeReturns := fake.buildGetUsedByReturns
	fake.recordInvocation("BuildGetUsedBy", []interface{}{arg1, arg2})
	fake.buildGetUsedByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) BuildGetUsedByCallCount() int {
	fake.buildGetUsedByMutex.RLock()
	defer fake.buildGetUsedByMutex.RUnlock()
	return len(fake.buildGetUsedByArgsForCall)
}

func (fake *FakeQuerier) BuildGetUsedByCalls(stub func(context.Context, string) ([]db.BuildGetUsedByRow, error)) {
	fake.buildGetUsedByMutex.Lock()
	defer fake.buildGetUsedByMutex.Unlock()
	fake.BuildGetUsedByStub = stub
}

func (fake *FakeQuerier) BuildGetUsedByArgsForCall(i int) (context.Context, string) {
	fake.buildGetUsedByMutex.RLock()
	defer fake.buildGetUsedByMutex.RUnlock()
	argsForCall := fake.buildGetUsedByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) BuildGetUsedByReturns(result1 []db.BuildGetUsedByRow, result2 error) {
	fake.buildGetUsedByMutex.Lock()
	defer fake.buildGetUsedByMutex.Unlock()
	fake.BuildGetUsedByStub = nil
	fake.buildGetUsedByReturns = struct {
		result1 []db.BuildGetUsedByRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildGetUsedByReturnsOnCall(i int, result1 []db.BuildGetUsedByRow, result2 error) {
	fake.buildGetUsedByMutex.Lock()
	defer fake.buildGetUsedByMutex.Unlock()
	fake.BuildGetUsedByStub = nil
	if fake.buildGetUsedByReturnsOnCall == nil {
		fake.buildGetUsedByReturnsOnCall = make(map[int]struct {
			result1 []db.BuildGetUsedByRow
			result2 error
		})
	}
	fake.buildGetUsedByReturnsOnCall[i] = struct {
		result1 []db.BuildGetUsedByRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) BuildUpdate(arg1 context.Context, arg2 db.BuildUpdateParams) error {
	fake.buildUpdateMutex.Lock()
	ret, specificReturn := fake.buildUpdateReturnsOnCall[len(fake.buildUpdateArgsForCall)]
	fake.buildUpdateArgsForCall = append(fake.buildUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 db.BuildUpdateParams
	}{arg1, arg2})
	stub := fake.BuildUpdateStub
	fakeReturns := fake.buildUpdateReturns
	fake.recordInvocation("BuildUpdate", []interface{}{arg1, arg2})
	fake.buildUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) BuildUpdateCallCount() int {
	fake.buildUpdateMutex.RLock()
	defer fake.buildUpdateMutex.RUnlock()
	return len(fake.buildUpdateArgsForCall)
}

func (fake *FakeQuerier) BuildUpdateCalls(stub func(context.Context, db.BuildUpdateParams) error) {
	fake.buildUpdateMutex.Lock()
	defer fake.buildUpdateMutex.Unlock()
	fake.BuildUpdateStub = stub
}

func (fake *FakeQuerier) BuildUpdateArgsForCall(i int) (context.Context, db.BuildUpdateParams) {
	fake.buildUpdateMutex.RLock()
	defer fake.buildUpdateMutex.RUnlock()
	argsForCall := fake.buildUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) BuildUpdateReturns(result1 error) {
	fake.buildUpdateMutex.Lock()
	defer fake.buildUpdateMutex.Unlock()
	fake.BuildUpdateStub = nil
	fake.buildUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) BuildUpdateReturnsOnCall(i int, result1 error) {
	fake.buildUpdateMutex.Lock()
	defer fake.buildUpdateMutex.Unlock()
	fake.BuildUpdateStub = nil
	if fake.buildUpdateReturnsOnCall == nil {
		fake.buildUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.buildUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheck(arg1 context.Context, arg2 string) (db.UnweaveEndpointCheck, error) {
	fake.endpointCheckMutex.Lock()
	ret, specificReturn := fake.endpointCheckReturnsOnCall[len(fake.endpointCheckArgsForCall)]
	fake.endpointCheckArgsForCall = append(fake.endpointCheckArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointCheckStub
	fakeReturns := fake.endpointCheckReturns
	fake.recordInvocation("EndpointCheck", []interface{}{arg1, arg2})
	fake.endpointCheckMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointCheckCallCount() int {
	fake.endpointCheckMutex.RLock()
	defer fake.endpointCheckMutex.RUnlock()
	return len(fake.endpointCheckArgsForCall)
}

func (fake *FakeQuerier) EndpointCheckCalls(stub func(context.Context, string) (db.UnweaveEndpointCheck, error)) {
	fake.endpointCheckMutex.Lock()
	defer fake.endpointCheckMutex.Unlock()
	fake.EndpointCheckStub = stub
}

func (fake *FakeQuerier) EndpointCheckArgsForCall(i int) (context.Context, string) {
	fake.endpointCheckMutex.RLock()
	defer fake.endpointCheckMutex.RUnlock()
	argsForCall := fake.endpointCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCheckReturns(result1 db.UnweaveEndpointCheck, result2 error) {
	fake.endpointCheckMutex.Lock()
	defer fake.endpointCheckMutex.Unlock()
	fake.EndpointCheckStub = nil
	fake.endpointCheckReturns = struct {
		result1 db.UnweaveEndpointCheck
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointCheckReturnsOnCall(i int, result1 db.UnweaveEndpointCheck, result2 error) {
	fake.endpointCheckMutex.Lock()
	defer fake.endpointCheckMutex.Unlock()
	fake.EndpointCheckStub = nil
	if fake.endpointCheckReturnsOnCall == nil {
		fake.endpointCheckReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveEndpointCheck
			result2 error
		})
	}
	fake.endpointCheckReturnsOnCall[i] = struct {
		result1 db.UnweaveEndpointCheck
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointCheckCreate(arg1 context.Context, arg2 db.EndpointCheckCreateParams) error {
	fake.endpointCheckCreateMutex.Lock()
	ret, specificReturn := fake.endpointCheckCreateReturnsOnCall[len(fake.endpointCheckCreateArgsForCall)]
	fake.endpointCheckCreateArgsForCall = append(fake.endpointCheckCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointCheckCreateParams
	}{arg1, arg2})
	stub := fake.EndpointCheckCreateStub
	fakeReturns := fake.endpointCheckCreateReturns
	fake.recordInvocation("EndpointCheckCreate", []interface{}{arg1, arg2})
	fake.endpointCheckCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointCheckCreateCallCount() int {
	fake.endpointCheckCreateMutex.RLock()
	defer fake.endpointCheckCreateMutex.RUnlock()
	return len(fake.endpointCheckCreateArgsForCall)
}

func (fake *FakeQuerier) EndpointCheckCreateCalls(stub func(context.Context, db.EndpointCheckCreateParams) error) {
	fake.endpointCheckCreateMutex.Lock()
	defer fake.endpointCheckCreateMutex.Unlock()
	fake.EndpointCheckCreateStub = stub
}

func (fake *FakeQuerier) EndpointCheckCreateArgsForCall(i int) (context.Context, db.EndpointCheckCreateParams) {
	fake.endpointCheckCreateMutex.RLock()
	defer fake.endpointCheckCreateMutex.RUnlock()
	argsForCall := fake.endpointCheckCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCheckCreateReturns(result1 error) {
	fake.endpointCheckCreateMutex.Lock()
	defer fake.endpointCheckCreateMutex.Unlock()
	fake.EndpointCheckCreateStub = nil
	fake.endpointCheckCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckCreateReturnsOnCall(i int, result1 error) {
	fake.endpointCheckCreateMutex.Lock()
	defer fake.endpointCheckCreateMutex.Unlock()
	fake.EndpointCheckCreateStub = nil
	if fake.endpointCheckCreateReturnsOnCall == nil {
		fake.endpointCheckCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointCheckCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckStepCreate(arg1 context.Context, arg2 db.EndpointCheckStepCreateParams) error {
	fake.endpointCheckStepCreateMutex.Lock()
	ret, specificReturn := fake.endpointCheckStepCreateReturnsOnCall[len(fake.endpointCheckStepCreateArgsForCall)]
	fake.endpointCheckStepCreateArgsForCall = append(fake.endpointCheckStepCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointCheckStepCreateParams
	}{arg1, arg2})
	stub := fake.EndpointCheckStepCreateStub
	fakeReturns := fake.endpointCheckStepCreateReturns
	fake.recordInvocation("EndpointCheckStepCreate", []interface{}{arg1, arg2})
	fake.endpointCheckStepCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointCheckStepCreateCallCount() int {
	fake.endpointCheckStepCreateMutex.RLock()
	defer fake.endpointCheckStepCreateMutex.RUnlock()
	return len(fake.endpointCheckStepCreateArgsForCall)
}

func (fake *FakeQuerier) EndpointCheckStepCreateCalls(stub func(context.Context, db.EndpointCheckStepCreateParams) error) {
	fake.endpointCheckStepCreateMutex.Lock()
	defer fake.endpointCheckStepCreateMutex.Unlock()
	fake.EndpointCheckStepCreateStub = stub
}

func (fake *FakeQuerier) EndpointCheckStepCreateArgsForCall(i int) (context.Context, db.EndpointCheckStepCreateParams) {
	fake.endpointCheckStepCreateMutex.RLock()
	defer fake.endpointCheckStepCreateMutex.RUnlock()
	argsForCall := fake.endpointCheckStepCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCheckStepCreateReturns(result1 error) {
	fake.endpointCheckStepCreateMutex.Lock()
	defer fake.endpointCheckStepCreateMutex.Unlock()
	fake.EndpointCheckStepCreateStub = nil
	fake.endpointCheckStepCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckStepCreateReturnsOnCall(i int, result1 error) {
	fake.endpointCheckStepCreateMutex.Lock()
	defer fake.endpointCheckStepCreateMutex.Unlock()
	fake.EndpointCheckStepCreateStub = nil
	if fake.endpointCheckStepCreateReturnsOnCall == nil {
		fake.endpointCheckStepCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointCheckStepCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckStepUpdate(arg1 context.Context, arg2 db.EndpointCheckStepUpdateParams) error {
	fake.endpointCheckStepUpdateMutex.Lock()
	ret, specificReturn := fake.endpointCheckStepUpdateReturnsOnCall[len(fake.endpointCheckStepUpdateArgsForCall)]
	fake.endpointCheckStepUpdateArgsForCall = append(fake.endpointCheckStepUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointCheckStepUpdateParams
	}{arg1, arg2})
	stub := fake.EndpointCheckStepUpdateStub
	fakeReturns := fake.endpointCheckStepUpdateReturns
	fake.recordInvocation("EndpointCheckStepUpdate", []interface{}{arg1, arg2})
	fake.endpointCheckStepUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointCheckStepUpdateCallCount() int {
	fake.endpointCheckStepUpdateMutex.RLock()
	defer fake.endpointCheckStepUpdateMutex.RUnlock()
	return len(fake.endpointCheckStepUpdateArgsForCall)
}

func (fake *FakeQuerier) EndpointCheckStepUpdateCalls(stub func(context.Context, db.EndpointCheckStepUpdateParams) error) {
	fake.endpointCheckStepUpdateMutex.Lock()
	defer fake.endpointCheckStepUpdateMutex.Unlock()
	fake.EndpointCheckStepUpdateStub = stub
}

func (fake *FakeQuerier) EndpointCheckStepUpdateArgsForCall(i int) (context.Context, db.EndpointCheckStepUpdateParams) {
	fake.endpointCheckStepUpdateMutex.RLock()
	defer fake.endpointCheckStepUpdateMutex.RUnlock()
	argsForCall := fake.endpointCheckStepUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCheckStepUpdateReturns(result1 error) {
	fake.endpointCheckStepUpdateMutex.Lock()
	defer fake.endpointCheckStepUpdateMutex.Unlock()
	fake.EndpointCheckStepUpdateStub = nil
	fake.endpointCheckStepUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckStepUpdateReturnsOnCall(i int, result1 error) {
	fake.endpointCheckStepUpdateMutex.Lock()
	defer fake.endpointCheckStepUpdateMutex.Unlock()
	fake.EndpointCheckStepUpdateStub = nil
	if fake.endpointCheckStepUpdateReturnsOnCall == nil {
		fake.endpointCheckStepUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointCheckStepUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCheckSteps(arg1 context.Context, arg2 string) ([]db.UnweaveEndpointCheckStep, error) {
	fake.endpointCheckStepsMutex.Lock()
	ret, specificReturn := fake.endpointCheckStepsReturnsOnCall[len(fake.endpointCheckStepsArgsForCall)]
	fake.endpointCheckStepsArgsForCall = append(fake.endpointCheckStepsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointCheckStepsStub
	fakeReturns := fake.endpointCheckStepsReturns
	fake.recordInvocation("EndpointCheckSteps", []interface{}{arg1, arg2})
	fake.endpointCheckStepsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointCheckStepsCallCount() int {
	fake.endpointCheckStepsMutex.RLock()
	defer fake.endpointCheckStepsMutex.RUnlock()
	return len(fake.endpointCheckStepsArgsForCall)
}

func (fake *FakeQuerier) EndpointCheckStepsCalls(stub func(context.Context, string) ([]db.UnweaveEndpointCheckStep, error)) {
	fake.endpointCheckStepsMutex.Lock()
	defer fake.endpointCheckStepsMutex.Unlock()
	fake.EndpointCheckStepsStub = stub
}

func (fake *FakeQuerier) EndpointCheckStepsArgsForCall(i int) (context.Context, string) {
	fake.endpointCheckStepsMutex.RLock()
	defer fake.endpointCheckStepsMutex.RUnlock()
	argsForCall := fake.endpointCheckStepsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCheckStepsReturns(result1 []db.UnweaveEndpointCheckStep, result2 error) {
	fake.endpointCheckStepsMutex.Lock()
	defer fake.endpointCheckStepsMutex.Unlock()
	fake.EndpointCheckStepsStub = nil
	fake.endpointCheckStepsReturns = struct {
		result1 []db.UnweaveEndpointCheckStep
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointCheckStepsReturnsOnCall(i int, result1 []db.UnweaveEndpointCheckStep, result2 error) {
	fake.endpointCheckStepsMutex.Lock()
	defer fake.endpointCheckStepsMutex.Unlock()
	fake.EndpointCheckStepsStub = nil
	if fake.endpointCheckStepsReturnsOnCall == nil {
		fake.endpointCheckStepsReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveEndpointCheckStep
			result2 error
		})
	}
	fake.endpointCheckStepsReturnsOnCall[i] = struct {
		result1 []db.UnweaveEndpointCheckStep
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointCreate(arg1 context.Context, arg2 db.EndpointCreateParams) error {
	fake.endpointCreateMutex.Lock()
	ret, specificReturn := fake.endpointCreateReturnsOnCall[len(fake.endpointCreateArgsForCall)]
	fake.endpointCreateArgsForCall = append(fake.endpointCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointCreateParams
	}{arg1, arg2})
	stub := fake.EndpointCreateStub
	fakeReturns := fake.endpointCreateReturns
	fake.recordInvocation("EndpointCreate", []interface{}{arg1, arg2})
	fake.endpointCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointCreateCallCount() int {
	fake.endpointCreateMutex.RLock()
	defer fake.endpointCreateMutex.RUnlock()
	return len(fake.endpointCreateArgsForCall)
}

func (fake *FakeQuerier) EndpointCreateCalls(stub func(context.Context, db.EndpointCreateParams) error) {
	fake.endpointCreateMutex.Lock()
	defer fake.endpointCreateMutex.Unlock()
	fake.EndpointCreateStub = stub
}

func (fake *FakeQuerier) EndpointCreateArgsForCall(i int) (context.Context, db.EndpointCreateParams) {
	fake.endpointCreateMutex.RLock()
	defer fake.endpointCreateMutex.RUnlock()
	argsForCall := fake.endpointCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointCreateReturns(result1 error) {
	fake.endpointCreateMutex.Lock()
	defer fake.endpointCreateMutex.Unlock()
	fake.EndpointCreateStub = nil
	fake.endpointCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointCreateReturnsOnCall(i int, result1 error) {
	fake.endpointCreateMutex.Lock()
	defer fake.endpointCreateMutex.Unlock()
	fake.EndpointCreateStub = nil
	if fake.endpointCreateReturnsOnCall == nil {
		fake.endpointCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointDelete(arg1 context.Context, arg2 string) error {
	fake.endpointDeleteMutex.Lock()
	ret, specificReturn := fake.endpointDeleteReturnsOnCall[len(fake.endpointDeleteArgsForCall)]
	fake.endpointDeleteArgsForCall = append(fake.endpointDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointDeleteStub
	fakeReturns := fake.endpointDeleteReturns
	fake.recordInvocation("EndpointDelete", []interface{}{arg1, arg2})
	fake.endpointDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointDeleteCallCount() int {
	fake.endpointDeleteMutex.RLock()
	defer fake.endpointDeleteMutex.RUnlock()
	return len(fake.endpointDeleteArgsForCall)
}

func (fake *FakeQuerier) EndpointDeleteCalls(stub func(context.Context, string) error) {
	fake.endpointDeleteMutex.Lock()
	defer fake.endpointDeleteMutex.Unlock()
	fake.EndpointDeleteStub = stub
}

func (fake *FakeQuerier) EndpointDeleteArgsForCall(i int) (context.Context, string) {
	fake.endpointDeleteMutex.RLock()
	defer fake.endpointDeleteMutex.RUnlock()
	argsForCall := fake.endpointDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointDeleteReturns(result1 error) {
	fake.endpointDeleteMutex.Lock()
	defer fake.endpointDeleteMutex.Unlock()
	fake.EndpointDeleteStub = nil
	fake.endpointDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointDeleteReturnsOnCall(i int, result1 error) {
	fake.endpointDeleteMutex.Lock()
	defer fake.endpointDeleteMutex.Unlock()
	fake.EndpointDeleteStub = nil
	if fake.endpointDeleteReturnsOnCall == nil {
		fake.endpointDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointEval(arg1 context.Context, arg2 string) ([]db.UnweaveEndpointEval, error) {
	fake.endpointEvalMutex.Lock()
	ret, specificReturn := fake.endpointEvalReturnsOnCall[len(fake.endpointEvalArgsForCall)]
	fake.endpointEvalArgsForCall = append(fake.endpointEvalArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointEvalStub
	fakeReturns := fake.endpointEvalReturns
	fake.recordInvocation("EndpointEval", []interface{}{arg1, arg2})
	fake.endpointEvalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointEvalCallCount() int {
	fake.endpointEvalMutex.RLock()
	defer fake.endpointEvalMutex.RUnlock()
	return len(fake.endpointEvalArgsForCall)
}

func (fake *FakeQuerier) EndpointEvalCalls(stub func(context.Context, string) ([]db.UnweaveEndpointEval, error)) {
	fake.endpointEvalMutex.Lock()
	defer fake.endpointEvalMutex.Unlock()
	fake.EndpointEvalStub = stub
}

func (fake *FakeQuerier) EndpointEvalArgsForCall(i int) (context.Context, string) {
	fake.endpointEvalMutex.RLock()
	defer fake.endpointEvalMutex.RUnlock()
	argsForCall := fake.endpointEvalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointEvalReturns(result1 []db.UnweaveEndpointEval, result2 error) {
	fake.endpointEvalMutex.Lock()
	defer fake.endpointEvalMutex.Unlock()
	fake.EndpointEvalStub = nil
	fake.endpointEvalReturns = struct {
		result1 []db.UnweaveEndpointEval
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointEvalReturnsOnCall(i int, result1 []db.UnweaveEndpointEval, result2 error) {
	fake.endpointEvalMutex.Lock()
	defer fake.endpointEvalMutex.Unlock()
	fake.EndpointEvalStub = nil
	if fake.endpointEvalReturnsOnCall == nil {
		fake.endpointEvalReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveEndpointEval
			result2 error
		})
	}
	fake.endpointEvalReturnsOnCall[i] = struct {
		result1 []db.UnweaveEndpointEval
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointEvalAttach(arg1 context.Context, arg2 db.EndpointEvalAttachParams) error {
	fake.endpointEvalAttachMutex.Lock()
	ret, specificReturn := fake.endpointEvalAttachReturnsOnCall[len(fake.endpointEvalAttachArgsForCall)]
	fake.endpointEvalAttachArgsForCall = append(fake.endpointEvalAttachArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointEvalAttachParams
	}{arg1, arg2})
	stub := fake.EndpointEvalAttachStub
	fakeReturns := fake.endpointEvalAttachReturns
	fake.recordInvocation("EndpointEvalAttach", []interface{}{arg1, arg2})
	fake.endpointEvalAttachMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointEvalAttachCallCount() int {
	fake.endpointEvalAttachMutex.RLock()
	defer fake.endpointEvalAttachMutex.RUnlock()
	return len(fake.endpointEvalAttachArgsForCall)
}

func (fake *FakeQuerier) EndpointEvalAttachCalls(stub func(context.Context, db.EndpointEvalAttachParams) error) {
	fake.endpointEvalAttachMutex.Lock()
	defer fake.endpointEvalAttachMutex.Unlock()
	fake.EndpointEvalAttachStub = stub
}

func (fake *FakeQuerier) EndpointEvalAttachArgsForCall(i int) (context.Context, db.EndpointEvalAttachParams) {
	fake.endpointEvalAttachMutex.RLock()
	defer fake.endpointEvalAttachMutex.RUnlock()
	argsForCall := fake.endpointEvalAttachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointEvalAttachReturns(result1 error) {
	fake.endpointEvalAttachMutex.Lock()
	defer fake.endpointEvalAttachMutex.Unlock()
	fake.EndpointEvalAttachStub = nil
	fake.endpointEvalAttachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointEvalAttachReturnsOnCall(i int, result1 error) {
	fake.endpointEvalAttachMutex.Lock()
	defer fake.endpointEvalAttachMutex.Unlock()
	fake.EndpointEvalAttachStub = nil
	if fake.endpointEvalAttachReturnsOnCall == nil {
		fake.endpointEvalAttachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointEvalAttachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointGet(arg1 context.Context, arg2 db.EndpointGetParams) (db.UnweaveEndpoint, error) {
	fake.endpointGetMutex.Lock()
	ret, specificReturn := fake.endpointGetReturnsOnCall[len(fake.endpointGetArgsForCall)]
	fake.endpointGetArgsForCall = append(fake.endpointGetArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointGetParams
	}{arg1, arg2})
	stub := fake.EndpointGetStub
	fakeReturns := fake.endpointGetReturns
	fake.recordInvocation("EndpointGet", []interface{}{arg1, arg2})
	fake.endpointGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointGetCallCount() int {
	fake.endpointGetMutex.RLock()
	defer fake.endpointGetMutex.RUnlock()
	return len(fake.endpointGetArgsForCall)
}

func (fake *FakeQuerier) EndpointGetCalls(stub func(context.Context, db.EndpointGetParams) (db.UnweaveEndpoint, error)) {
	fake.endpointGetMutex.Lock()
	defer fake.endpointGetMutex.Unlock()
	fake.EndpointGetStub = stub
}

func (fake *FakeQuerier) EndpointGetArgsForCall(i int) (context.Context, db.EndpointGetParams) {
	fake.endpointGetMutex.RLock()
	defer fake.endpointGetMutex.RUnlock()
	argsForCall := fake.endpointGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointGetReturns(result1 db.UnweaveEndpoint, result2 error) {
	fake.endpointGetMutex.Lock()
	defer fake.endpointGetMutex.Unlock()
	fake.EndpointGetStub = nil
	fake.endpointGetReturns = struct {
		result1 db.UnweaveEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointGetReturnsOnCall(i int, result1 db.UnweaveEndpoint, result2 error) {
	fake.endpointGetMutex.Lock()
	defer fake.endpointGetMutex.Unlock()
	fake.EndpointGetStub = nil
	if fake.endpointGetReturnsOnCall == nil {
		fake.endpointGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveEndpoint
			result2 error
		})
	}
	fake.endpointGetReturnsOnCall[i] = struct {
		result1 db.UnweaveEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointVersion(arg1 context.Context, arg2 string) (db.UnweaveEndpointVersion, error) {
	fake.endpointVersionMutex.Lock()
	ret, specificReturn := fake.endpointVersionReturnsOnCall[len(fake.endpointVersionArgsForCall)]
	fake.endpointVersionArgsForCall = append(fake.endpointVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointVersionStub
	fakeReturns := fake.endpointVersionReturns
	fake.recordInvocation("EndpointVersion", []interface{}{arg1, arg2})
	fake.endpointVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointVersionCallCount() int {
	fake.endpointVersionMutex.RLock()
	defer fake.endpointVersionMutex.RUnlock()
	return len(fake.endpointVersionArgsForCall)
}

func (fake *FakeQuerier) EndpointVersionCalls(stub func(context.Context, string) (db.UnweaveEndpointVersion, error)) {
	fake.endpointVersionMutex.Lock()
	defer fake.endpointVersionMutex.Unlock()
	fake.EndpointVersionStub = stub
}

func (fake *FakeQuerier) EndpointVersionArgsForCall(i int) (context.Context, string) {
	fake.endpointVersionMutex.RLock()
	defer fake.endpointVersionMutex.RUnlock()
	argsForCall := fake.endpointVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointVersionReturns(result1 db.UnweaveEndpointVersion, result2 error) {
	fake.endpointVersionMutex.Lock()
	defer fake.endpointVersionMutex.Unlock()
	fake.EndpointVersionStub = nil
	fake.endpointVersionReturns = struct {
		result1 db.UnweaveEndpointVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointVersionReturnsOnCall(i int, result1 db.UnweaveEndpointVersion, result2 error) {
	fake.endpointVersionMutex.Lock()
	defer fake.endpointVersionMutex.Unlock()
	fake.EndpointVersionStub = nil
	if fake.endpointVersionReturnsOnCall == nil {
		fake.endpointVersionReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveEndpointVersion
			result2 error
		})
	}
	fake.endpointVersionReturnsOnCall[i] = struct {
		result1 db.UnweaveEndpointVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointVersionCreate(arg1 context.Context, arg2 db.EndpointVersionCreateParams) error {
	fake.endpointVersionCreateMutex.Lock()
	ret, specificReturn := fake.endpointVersionCreateReturnsOnCall[len(fake.endpointVersionCreateArgsForCall)]
	fake.endpointVersionCreateArgsForCall = append(fake.endpointVersionCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EndpointVersionCreateParams
	}{arg1, arg2})
	stub := fake.EndpointVersionCreateStub
	fakeReturns := fake.endpointVersionCreateReturns
	fake.recordInvocation("EndpointVersionCreate", []interface{}{arg1, arg2})
	fake.endpointVersionCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointVersionCreateCallCount() int {
	fake.endpointVersionCreateMutex.RLock()
	defer fake.endpointVersionCreateMutex.RUnlock()
	return len(fake.endpointVersionCreateArgsForCall)
}

func (fake *FakeQuerier) EndpointVersionCreateCalls(stub func(context.Context, db.EndpointVersionCreateParams) error) {
	fake.endpointVersionCreateMutex.Lock()
	defer fake.endpointVersionCreateMutex.Unlock()
	fake.EndpointVersionCreateStub = stub
}

func (fake *FakeQuerier) EndpointVersionCreateArgsForCall(i int) (context.Context, db.EndpointVersionCreateParams) {
	fake.endpointVersionCreateMutex.RLock()
	defer fake.endpointVersionCreateMutex.RUnlock()
	argsForCall := fake.endpointVersionCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointVersionCreateReturns(result1 error) {
	fake.endpointVersionCreateMutex.Lock()
	defer fake.endpointVersionCreateMutex.Unlock()
	fake.EndpointVersionCreateStub = nil
	fake.endpointVersionCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointVersionCreateReturnsOnCall(i int, result1 error) {
	fake.endpointVersionCreateMutex.Lock()
	defer fake.endpointVersionCreateMutex.Unlock()
	fake.EndpointVersionCreateStub = nil
	if fake.endpointVersionCreateReturnsOnCall == nil {
		fake.endpointVersionCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointVersionCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointVersionDemote(arg1 context.Context, arg2 string) error {
	fake.endpointVersionDemoteMutex.Lock()
	ret, specificReturn := fake.endpointVersionDemoteReturnsOnCall[len(fake.endpointVersionDemoteArgsForCall)]
	fake.endpointVersionDemoteArgsForCall = append(fake.endpointVersionDemoteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointVersionDemoteStub
	fakeReturns := fake.endpointVersionDemoteReturns
	fake.recordInvocation("EndpointVersionDemote", []interface{}{arg1, arg2})
	fake.endpointVersionDemoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointVersionDemoteCallCount() int {
	fake.endpointVersionDemoteMutex.RLock()
	defer fake.endpointVersionDemoteMutex.RUnlock()
	return len(fake.endpointVersionDemoteArgsForCall)
}

func (fake *FakeQuerier) EndpointVersionDemoteCalls(stub func(context.Context, string) error) {
	fake.endpointVersionDemoteMutex.Lock()
	defer fake.endpointVersionDemoteMutex.Unlock()
	fake.EndpointVersionDemoteStub = stub
}

func (fake *FakeQuerier) EndpointVersionDemoteArgsForCall(i int) (context.Context, string) {
	fake.endpointVersionDemoteMutex.RLock()
	defer fake.endpointVersionDemoteMutex.RUnlock()
	argsForCall := fake.endpointVersionDemoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointVersionDemoteReturns(result1 error) {
	fake.endpointVersionDemoteMutex.Lock()
	defer fake.endpointVersionDemoteMutex.Unlock()
	fake.EndpointVersionDemoteStub = nil
	fake.endpointVersionDemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointVersionDemoteReturnsOnCall(i int, result1 error) {
	fake.endpointVersionDemoteMutex.Lock()
	defer fake.endpointVersionDemoteMutex.Unlock()
	fake.EndpointVersionDemoteStub = nil
	if fake.endpointVersionDemoteReturnsOnCall == nil {
		fake.endpointVersionDemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointVersionDemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointVersionList(arg1 context.Context, arg2 string) ([]db.UnweaveEndpointVersion, error) {
	fake.endpointVersionListMutex.Lock()
	ret, specificReturn := fake.endpointVersionListReturnsOnCall[len(fake.endpointVersionListArgsForCall)]
	fake.endpointVersionListArgsForCall = append(fake.endpointVersionListArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointVersionListStub
	fakeReturns := fake.endpointVersionListReturns
	fake.recordInvocation("EndpointVersionList", []interface{}{arg1, arg2})
	fake.endpointVersionListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointVersionListCallCount() int {
	fake.endpointVersionListMutex.RLock()
	defer fake.endpointVersionListMutex.RUnlock()
	return len(fake.endpointVersionListArgsForCall)
}

func (fake *FakeQuerier) EndpointVersionListCalls(stub func(context.Context, string) ([]db.UnweaveEndpointVersion, error)) {
	fake.endpointVersionListMutex.Lock()
	defer fake.endpointVersionListMutex.Unlock()
	fake.EndpointVersionListStub = stub
}

func (fake *FakeQuerier) EndpointVersionListArgsForCall(i int) (context.Context, string) {
	fake.endpointVersionListMutex.RLock()
	defer fake.endpointVersionListMutex.RUnlock()
	argsForCall := fake.endpointVersionListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointVersionListReturns(result1 []db.UnweaveEndpointVersion, result2 error) {
	fake.endpointVersionListMutex.Lock()
	defer fake.endpointVersionListMutex.Unlock()
	fake.EndpointVersionListStub = nil
	fake.endpointVersionListReturns = struct {
		result1 []db.UnweaveEndpointVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointVersionListReturnsOnCall(i int, result1 []db.UnweaveEndpointVersion, result2 error) {
	fake.endpointVersionListMutex.Lock()
	defer fake.endpointVersionListMutex.Unlock()
	fake.EndpointVersionListStub = nil
	if fake.endpointVersionListReturnsOnCall == nil {
		fake.endpointVersionListReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveEndpointVersion
			result2 error
		})
	}
	fake.endpointVersionListReturnsOnCall[i] = struct {
		result1 []db.UnweaveEndpointVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointVersionPromote(arg1 context.Context, arg2 string) error {
	fake.endpointVersionPromoteMutex.Lock()
	ret, specificReturn := fake.endpointVersionPromoteReturnsOnCall[len(fake.endpointVersionPromoteArgsForCall)]
	fake.endpointVersionPromoteArgsForCall = append(fake.endpointVersionPromoteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointVersionPromoteStub
	fakeReturns := fake.endpointVersionPromoteReturns
	fake.recordInvocation("EndpointVersionPromote", []interface{}{arg1, arg2})
	fake.endpointVersionPromoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EndpointVersionPromoteCallCount() int {
	fake.endpointVersionPromoteMutex.RLock()
	defer fake.endpointVersionPromoteMutex.RUnlock()
	return len(fake.endpointVersionPromoteArgsForCall)
}

func (fake *FakeQuerier) EndpointVersionPromoteCalls(stub func(context.Context, string) error) {
	fake.endpointVersionPromoteMutex.Lock()
	defer fake.endpointVersionPromoteMutex.Unlock()
	fake.EndpointVersionPromoteStub = stub
}

func (fake *FakeQuerier) EndpointVersionPromoteArgsForCall(i int) (context.Context, string) {
	fake.endpointVersionPromoteMutex.RLock()
	defer fake.endpointVersionPromoteMutex.RUnlock()
	argsForCall := fake.endpointVersionPromoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointVersionPromoteReturns(result1 error) {
	fake.endpointVersionPromoteMutex.Lock()
	defer fake.endpointVersionPromoteMutex.Unlock()
	fake.EndpointVersionPromoteStub = nil
	fake.endpointVersionPromoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointVersionPromoteReturnsOnCall(i int, result1 error) {
	fake.endpointVersionPromoteMutex.Lock()
	defer fake.endpointVersionPromoteMutex.Unlock()
	fake.EndpointVersionPromoteStub = nil
	if fake.endpointVersionPromoteReturnsOnCall == nil {
		fake.endpointVersionPromoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endpointVersionPromoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EndpointsForProject(arg1 context.Context, arg2 string) ([]db.UnweaveEndpoint, error) {
	fake.endpointsForProjectMutex.Lock()
	ret, specificReturn := fake.endpointsForProjectReturnsOnCall[len(fake.endpointsForProjectArgsForCall)]
	fake.endpointsForProjectArgsForCall = append(fake.endpointsForProjectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EndpointsForProjectStub
	fakeReturns := fake.endpointsForProjectReturns
	fake.recordInvocation("EndpointsForProject", []interface{}{arg1, arg2})
	fake.endpointsForProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EndpointsForProjectCallCount() int {
	fake.endpointsForProjectMutex.RLock()
	defer fake.endpointsForProjectMutex.RUnlock()
	return len(fake.endpointsForProjectArgsForCall)
}

func (fake *FakeQuerier) EndpointsForProjectCalls(stub func(context.Context, string) ([]db.UnweaveEndpoint, error)) {
	fake.endpointsForProjectMutex.Lock()
	defer fake.endpointsForProjectMutex.Unlock()
	fake.EndpointsForProjectStub = stub
}

func (fake *FakeQuerier) EndpointsForProjectArgsForCall(i int) (context.Context, string) {
	fake.endpointsForProjectMutex.RLock()
	defer fake.endpointsForProjectMutex.RUnlock()
	argsForCall := fake.endpointsForProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EndpointsForProjectReturns(result1 []db.UnweaveEndpoint, result2 error) {
	fake.endpointsForProjectMutex.Lock()
	defer fake.endpointsForProjectMutex.Unlock()
	fake.EndpointsForProjectStub = nil
	fake.endpointsForProjectReturns = struct {
		result1 []db.UnweaveEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EndpointsForProjectReturnsOnCall(i int, result1 []db.UnweaveEndpoint, result2 error) {
	fake.endpointsForProjectMutex.Lock()
	defer fake.endpointsForProjectMutex.Unlock()
	fake.EndpointsForProjectStub = nil
	if fake.endpointsForProjectReturnsOnCall == nil {
		fake.endpointsForProjectReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveEndpoint
			result2 error
		})
	}
	fake.endpointsForProjectReturnsOnCall[i] = struct {
		result1 []db.UnweaveEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalCreate(arg1 context.Context, arg2 db.EvalCreateParams) error {
	fake.evalCreateMutex.Lock()
	ret, specificReturn := fake.evalCreateReturnsOnCall[len(fake.evalCreateArgsForCall)]
	fake.evalCreateArgsForCall = append(fake.evalCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.EvalCreateParams
	}{arg1, arg2})
	stub := fake.EvalCreateStub
	fakeReturns := fake.evalCreateReturns
	fake.recordInvocation("EvalCreate", []interface{}{arg1, arg2})
	fake.evalCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EvalCreateCallCount() int {
	fake.evalCreateMutex.RLock()
	defer fake.evalCreateMutex.RUnlock()
	return len(fake.evalCreateArgsForCall)
}

func (fake *FakeQuerier) EvalCreateCalls(stub func(context.Context, db.EvalCreateParams) error) {
	fake.evalCreateMutex.Lock()
	defer fake.evalCreateMutex.Unlock()
	fake.EvalCreateStub = stub
}

func (fake *FakeQuerier) EvalCreateArgsForCall(i int) (context.Context, db.EvalCreateParams) {
	fake.evalCreateMutex.RLock()
	defer fake.evalCreateMutex.RUnlock()
	argsForCall := fake.evalCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EvalCreateReturns(result1 error) {
	fake.evalCreateMutex.Lock()
	defer fake.evalCreateMutex.Unlock()
	fake.EvalCreateStub = nil
	fake.evalCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EvalCreateReturnsOnCall(i int, result1 error) {
	fake.evalCreateMutex.Lock()
	defer fake.evalCreateMutex.Unlock()
	fake.EvalCreateStub = nil
	if fake.evalCreateReturnsOnCall == nil {
		fake.evalCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evalCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EvalDelete(arg1 context.Context, arg2 string) error {
	fake.evalDeleteMutex.Lock()
	ret, specificReturn := fake.evalDeleteReturnsOnCall[len(fake.evalDeleteArgsForCall)]
	fake.evalDeleteArgsForCall = append(fake.evalDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EvalDeleteStub
	fakeReturns := fake.evalDeleteReturns
	fake.recordInvocation("EvalDelete", []interface{}{arg1, arg2})
	fake.evalDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) EvalDeleteCallCount() int {
	fake.evalDeleteMutex.RLock()
	defer fake.evalDeleteMutex.RUnlock()
	return len(fake.evalDeleteArgsForCall)
}

func (fake *FakeQuerier) EvalDeleteCalls(stub func(context.Context, string) error) {
	fake.evalDeleteMutex.Lock()
	defer fake.evalDeleteMutex.Unlock()
	fake.EvalDeleteStub = stub
}

func (fake *FakeQuerier) EvalDeleteArgsForCall(i int) (context.Context, string) {
	fake.evalDeleteMutex.RLock()
	defer fake.evalDeleteMutex.RUnlock()
	argsForCall := fake.evalDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EvalDeleteReturns(result1 error) {
	fake.evalDeleteMutex.Lock()
	defer fake.evalDeleteMutex.Unlock()
	fake.EvalDeleteStub = nil
	fake.evalDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EvalDeleteReturnsOnCall(i int, result1 error) {
	fake.evalDeleteMutex.Lock()
	defer fake.evalDeleteMutex.Unlock()
	fake.EvalDeleteStub = nil
	if fake.evalDeleteReturnsOnCall == nil {
		fake.evalDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evalDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) EvalGet(arg1 context.Context, arg2 string) (db.EvalGetRow, error) {
	fake.evalGetMutex.Lock()
	ret, specificReturn := fake.evalGetReturnsOnCall[len(fake.evalGetArgsForCall)]
	fake.evalGetArgsForCall = append(fake.evalGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EvalGetStub
	fakeReturns := fake.evalGetReturns
	fake.recordInvocation("EvalGet", []interface{}{arg1, arg2})
	fake.evalGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EvalGetCallCount() int {
	fake.evalGetMutex.RLock()
	defer fake.evalGetMutex.RUnlock()
	return len(fake.evalGetArgsForCall)
}

func (fake *FakeQuerier) EvalGetCalls(stub func(context.Context, string) (db.EvalGetRow, error)) {
	fake.evalGetMutex.Lock()
	defer fake.evalGetMutex.Unlock()
	fake.EvalGetStub = stub
}

func (fake *FakeQuerier) EvalGetArgsForCall(i int) (context.Context, string) {
	fake.evalGetMutex.RLock()
	defer fake.evalGetMutex.RUnlock()
	argsForCall := fake.evalGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EvalGetReturns(result1 db.EvalGetRow, result2 error) {
	fake.evalGetMutex.Lock()
	defer fake.evalGetMutex.Unlock()
	fake.EvalGetStub = nil
	fake.evalGetReturns = struct {
		result1 db.EvalGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalGetReturnsOnCall(i int, result1 db.EvalGetRow, result2 error) {
	fake.evalGetMutex.Lock()
	defer fake.evalGetMutex.Unlock()
	fake.EvalGetStub = nil
	if fake.evalGetReturnsOnCall == nil {
		fake.evalGetReturnsOnCall = make(map[int]struct {
			result1 db.EvalGetRow
			result2 error
		})
	}
	fake.evalGetReturnsOnCall[i] = struct {
		result1 db.EvalGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalList(arg1 context.Context, arg2 []string) ([]db.EvalListRow, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.evalListMutex.Lock()
	ret, specificReturn := fake.evalListReturnsOnCall[len(fake.evalListArgsForCall)]
	fake.evalListArgsForCall = append(fake.evalListArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.EvalListStub
	fakeReturns := fake.evalListReturns
	fake.recordInvocation("EvalList", []interface{}{arg1, arg2Copy})
	fake.evalListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EvalListCallCount() int {
	fake.evalListMutex.RLock()
	defer fake.evalListMutex.RUnlock()
	return len(fake.evalListArgsForCall)
}

func (fake *FakeQuerier) EvalListCalls(stub func(context.Context, []string) ([]db.EvalListRow, error)) {
	fake.evalListMutex.Lock()
	defer fake.evalListMutex.Unlock()
	fake.EvalListStub = stub
}

func (fake *FakeQuerier) EvalListArgsForCall(i int) (context.Context, []string) {
	fake.evalListMutex.RLock()
	defer fake.evalListMutex.RUnlock()
	argsForCall := fake.evalListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EvalListReturns(result1 []db.EvalListRow, result2 error) {
	fake.evalListMutex.Lock()
	defer fake.evalListMutex.Unlock()
	fake.EvalListStub = nil
	fake.evalListReturns = struct {
		result1 []db.EvalListRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalListReturnsOnCall(i int, result1 []db.EvalListRow, result2 error) {
	fake.evalListMutex.Lock()
	defer fake.evalListMutex.Unlock()
	fake.EvalListStub = nil
	if fake.evalListReturnsOnCall == nil {
		fake.evalListReturnsOnCall = make(map[int]struct {
			result1 []db.EvalListRow
			result2 error
		})
	}
	fake.evalListReturnsOnCall[i] = struct {
		result1 []db.EvalListRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalListForProject(arg1 context.Context, arg2 string) ([]db.EvalListForProjectRow, error) {
	fake.evalListForProjectMutex.Lock()
	ret, specificReturn := fake.evalListForProjectReturnsOnCall[len(fake.evalListForProjectArgsForCall)]
	fake.evalListForProjectArgsForCall = append(fake.evalListForProjectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EvalListForProjectStub
	fakeReturns := fake.evalListForProjectReturns
	fake.recordInvocation("EvalListForProject", []interface{}{arg1, arg2})
	fake.evalListForProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) EvalListForProjectCallCount() int {
	fake.evalListForProjectMutex.RLock()
	defer fake.evalListForProjectMutex.RUnlock()
	return len(fake.evalListForProjectArgsForCall)
}

func (fake *FakeQuerier) EvalListForProjectCalls(stub func(context.Context, string) ([]db.EvalListForProjectRow, error)) {
	fake.evalListForProjectMutex.Lock()
	defer fake.evalListForProjectMutex.Unlock()
	fake.EvalListForProjectStub = stub
}

func (fake *FakeQuerier) EvalListForProjectArgsForCall(i int) (context.Context, string) {
	fake.evalListForProjectMutex.RLock()
	defer fake.evalListForProjectMutex.RUnlock()
	argsForCall := fake.evalListForProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) EvalListForProjectReturns(result1 []db.EvalListForProjectRow, result2 error) {
	fake.evalListForProjectMutex.Lock()
	defer fake.evalListForProjectMutex.Unlock()
	fake.EvalListForProjectStub = nil
	fake.evalListForProjectReturns = struct {
		result1 []db.EvalListForProjectRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) EvalListForProjectReturnsOnCall(i int, result1 []db.EvalListForProjectRow, result2 error) {
	fake.evalListForProjectMutex.Lock()
	defer fake.evalListForProjectMutex.Unlock()
	fake.EvalListForProjectStub = nil
	if fake.evalListForProjectReturnsOnCall == nil {
		fake.evalListForProjectReturnsOnCall = make(map[int]struct {
			result1 []db.EvalListForProjectRow
			result2 error
		})
	}
	fake.evalListForProjectReturnsOnCall[i] = struct {
		result1 []db.EvalListForProjectRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecCreate(arg1 context.Context, arg2 db.ExecCreateParams) error {
	fake.execCreateMutex.Lock()
	ret, specificReturn := fake.execCreateReturnsOnCall[len(fake.execCreateArgsForCall)]
	fake.execCreateArgsForCall = append(fake.execCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecCreateParams
	}{arg1, arg2})
	stub := fake.ExecCreateStub
	fakeReturns := fake.execCreateReturns
	fake.recordInvocation("ExecCreate", []interface{}{arg1, arg2})
	fake.execCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecCreateCallCount() int {
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	return len(fake.execCreateArgsForCall)
}

func (fake *FakeQuerier) ExecCreateCalls(stub func(context.Context, db.ExecCreateParams) error) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = stub
}

func (fake *FakeQuerier) ExecCreateArgsForCall(i int) (context.Context, db.ExecCreateParams) {
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	argsForCall := fake.execCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecCreateReturns(result1 error) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = nil
	fake.execCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecCreateReturnsOnCall(i int, result1 error) {
	fake.execCreateMutex.Lock()
	defer fake.execCreateMutex.Unlock()
	fake.ExecCreateStub = nil
	if fake.execCreateReturnsOnCall == nil {
		fake.execCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecGet(arg1 context.Context, arg2 string) (db.UnweaveExec, error) {
	fake.execGetMutex.Lock()
	ret, specificReturn := fake.execGetReturnsOnCall[len(fake.execGetArgsForCall)]
	fake.execGetArgsForCall = append(fake.execGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecGetStub
	fakeReturns := fake.execGetReturns
	fake.recordInvocation("ExecGet", []interface{}{arg1, arg2})
	fake.execGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecGetCallCount() int {
	fake.execGetMutex.RLock()
	defer fake.execGetMutex.RUnlock()
	return len(fake.execGetArgsForCall)
}

func (fake *FakeQuerier) ExecGetCalls(stub func(context.Context, string) (db.UnweaveExec, error)) {
	fake.execGetMutex.Lock()
	defer fake.execGetMutex.Unlock()
	fake.ExecGetStub = stub
}

func (fake *FakeQuerier) ExecGetArgsForCall(i int) (context.Context, string) {
	fake.execGetMutex.RLock()
	defer fake.execGetMutex.RUnlock()
	argsForCall := fake.execGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecGetReturns(result1 db.UnweaveExec, result2 error) {
	fake.execGetMutex.Lock()
	defer fake.execGetMutex.Unlock()
	fake.ExecGetStub = nil
	fake.execGetReturns = struct {
		result1 db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecGetReturnsOnCall(i int, result1 db.UnweaveExec, result2 error) {
	fake.execGetMutex.Lock()
	defer fake.execGetMutex.Unlock()
	fake.ExecGetStub = nil
	if fake.execGetReturnsOnCall == nil {
		fake.execGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveExec
			result2 error
		})
	}
	fake.execGetReturnsOnCall[i] = struct {
		result1 db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecGetAllActive(arg1 context.Context) ([]db.UnweaveExec, error) {
	fake.execGetAllActiveMutex.Lock()
	ret, specificReturn := fake.execGetAllActiveReturnsOnCall[len(fake.execGetAllActiveArgsForCall)]
	fake.execGetAllActiveArgsForCall = append(fake.execGetAllActiveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ExecGetAllActiveStub
	fakeReturns := fake.execGetAllActiveReturns
	fake.recordInvocation("ExecGetAllActive", []interface{}{arg1})
	fake.execGetAllActiveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecGetAllActiveCallCount() int {
	fake.execGetAllActiveMutex.RLock()
	defer fake.execGetAllActiveMutex.RUnlock()
	return len(fake.execGetAllActiveArgsForCall)
}

func (fake *FakeQuerier) ExecGetAllActiveCalls(stub func(context.Context) ([]db.UnweaveExec, error)) {
	fake.execGetAllActiveMutex.Lock()
	defer fake.execGetAllActiveMutex.Unlock()
	fake.ExecGetAllActiveStub = stub
}

func (fake *FakeQuerier) ExecGetAllActiveArgsForCall(i int) context.Context {
	fake.execGetAllActiveMutex.RLock()
	defer fake.execGetAllActiveMutex.RUnlock()
	argsForCall := fake.execGetAllActiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuerier) ExecGetAllActiveReturns(result1 []db.UnweaveExec, result2 error) {
	fake.execGetAllActiveMutex.Lock()
	defer fake.execGetAllActiveMutex.Unlock()
	fake.ExecGetAllActiveStub = nil
	fake.execGetAllActiveReturns = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecGetAllActiveReturnsOnCall(i int, result1 []db.UnweaveExec, result2 error) {
	fake.execGetAllActiveMutex.Lock()
	defer fake.execGetAllActiveMutex.Unlock()
	fake.ExecGetAllActiveStub = nil
	if fake.execGetAllActiveReturnsOnCall == nil {
		fake.execGetAllActiveReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExec
			result2 error
		})
	}
	fake.execGetAllActiveReturnsOnCall[i] = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecList(arg1 context.Context, arg2 db.ExecListParams) ([]db.UnweaveExec, error) {
	fake.execListMutex.Lock()
	ret, specificReturn := fake.execListReturnsOnCall[len(fake.execListArgsForCall)]
	fake.execListArgsForCall = append(fake.execListArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecListParams
	}{arg1, arg2})
	stub := fake.ExecListStub
	fakeReturns := fake.execListReturns
	fake.recordInvocation("ExecList", []interface{}{arg1, arg2})
	fake.execListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecListCallCount() int {
	fake.execListMutex.RLock()
	defer fake.execListMutex.RUnlock()
	return len(fake.execListArgsForCall)
}

func (fake *FakeQuerier) ExecListCalls(stub func(context.Context, db.ExecListParams) ([]db.UnweaveExec, error)) {
	fake.execListMutex.Lock()
	defer fake.execListMutex.Unlock()
	fake.ExecListStub = stub
}

func (fake *FakeQuerier) ExecListArgsForCall(i int) (context.Context, db.ExecListParams) {
	fake.execListMutex.RLock()
	defer fake.execListMutex.RUnlock()
	argsForCall := fake.execListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecListReturns(result1 []db.UnweaveExec, result2 error) {
	fake.execListMutex.Lock()
	defer fake.execListMutex.Unlock()
	fake.ExecListStub = nil
	fake.execListReturns = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecListReturnsOnCall(i int, result1 []db.UnweaveExec, result2 error) {
	fake.execListMutex.Lock()
	defer fake.execListMutex.Unlock()
	fake.ExecListStub = nil
	if fake.execListReturnsOnCall == nil {
		fake.execListReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExec
			result2 error
		})
	}
	fake.execListReturnsOnCall[i] = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecListActiveByProvider(arg1 context.Context, arg2 string) ([]db.UnweaveExec, error) {
	fake.execListActiveByProviderMutex.Lock()
	ret, specificReturn := fake.execListActiveByProviderReturnsOnCall[len(fake.execListActiveByProviderArgsForCall)]
	fake.execListActiveByProviderArgsForCall = append(fake.execListActiveByProviderArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecListActiveByProviderStub
	fakeReturns := fake.execListActiveByProviderReturns
	fake.recordInvocation("ExecListActiveByProvider", []interface{}{arg1, arg2})
	fake.execListActiveByProviderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecListActiveByProviderCallCount() int {
	fake.execListActiveByProviderMutex.RLock()
	defer fake.execListActiveByProviderMutex.RUnlock()
	return len(fake.execListActiveByProviderArgsForCall)
}

func (fake *FakeQuerier) ExecListActiveByProviderCalls(stub func(context.Context, string) ([]db.UnweaveExec, error)) {
	fake.execListActiveByProviderMutex.Lock()
	defer fake.execListActiveByProviderMutex.Unlock()
	fake.ExecListActiveByProviderStub = stub
}

func (fake *FakeQuerier) ExecListActiveByProviderArgsForCall(i int) (context.Context, string) {
	fake.execListActiveByProviderMutex.RLock()
	defer fake.execListActiveByProviderMutex.RUnlock()
	argsForCall := fake.execListActiveByProviderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecListActiveByProviderReturns(result1 []db.UnweaveExec, result2 error) {
	fake.execListActiveByProviderMutex.Lock()
	defer fake.execListActiveByProviderMutex.Unlock()
	fake.ExecListActiveByProviderStub = nil
	fake.execListActiveByProviderReturns = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecListActiveByProviderReturnsOnCall(i int, result1 []db.UnweaveExec, result2 error) {
	fake.execListActiveByProviderMutex.Lock()
	defer fake.execListActiveByProviderMutex.Unlock()
	fake.ExecListActiveByProviderStub = nil
	if fake.execListActiveByProviderReturnsOnCall == nil {
		fake.execListActiveByProviderReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExec
			result2 error
		})
	}
	fake.execListActiveByProviderReturnsOnCall[i] = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecListByProvider(arg1 context.Context, arg2 string) ([]db.UnweaveExec, error) {
	fake.execListByProviderMutex.Lock()
	ret, specificReturn := fake.execListByProviderReturnsOnCall[len(fake.execListByProviderArgsForCall)]
	fake.execListByProviderArgsForCall = append(fake.execListByProviderArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecListByProviderStub
	fakeReturns := fake.execListByProviderReturns
	fake.recordInvocation("ExecListByProvider", []interface{}{arg1, arg2})
	fake.execListByProviderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecListByProviderCallCount() int {
	fake.execListByProviderMutex.RLock()
	defer fake.execListByProviderMutex.RUnlock()
	return len(fake.execListByProviderArgsForCall)
}

func (fake *FakeQuerier) ExecListByProviderCalls(stub func(context.Context, string) ([]db.UnweaveExec, error)) {
	fake.execListByProviderMutex.Lock()
	defer fake.execListByProviderMutex.Unlock()
	fake.ExecListByProviderStub = stub
}

func (fake *FakeQuerier) ExecListByProviderArgsForCall(i int) (context.Context, string) {
	fake.execListByProviderMutex.RLock()
	defer fake.execListByProviderMutex.RUnlock()
	argsForCall := fake.execListByProviderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecListByProviderReturns(result1 []db.UnweaveExec, result2 error) {
	fake.execListByProviderMutex.Lock()
	defer fake.execListByProviderMutex.Unlock()
	fake.ExecListByProviderStub = nil
	fake.execListByProviderReturns = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecListByProviderReturnsOnCall(i int, result1 []db.UnweaveExec, result2 error) {
	fake.execListByProviderMutex.Lock()
	defer fake.execListByProviderMutex.Unlock()
	fake.ExecListByProviderStub = nil
	if fake.execListByProviderReturnsOnCall == nil {
		fake.execListByProviderReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExec
			result2 error
		})
	}
	fake.execListByProviderReturnsOnCall[i] = struct {
		result1 []db.UnweaveExec
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecSSHKeyDelete(arg1 context.Context, arg2 db.ExecSSHKeyDeleteParams) error {
	fake.execSSHKeyDeleteMutex.Lock()
	ret, specificReturn := fake.execSSHKeyDeleteReturnsOnCall[len(fake.execSSHKeyDeleteArgsForCall)]
	fake.execSSHKeyDeleteArgsForCall = append(fake.execSSHKeyDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyDeleteParams
	}{arg1, arg2})
	stub := fake.ExecSSHKeyDeleteStub
	fakeReturns := fake.execSSHKeyDeleteReturns
	fake.recordInvocation("ExecSSHKeyDelete", []interface{}{arg1, arg2})
	fake.execSSHKeyDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecSSHKeyDeleteCallCount() int {
	fake.execSSHKeyDeleteMutex.RLock()
	defer fake.execSSHKeyDeleteMutex.RUnlock()
	return len(fake.execSSHKeyDeleteArgsForCall)
}

func (fake *FakeQuerier) ExecSSHKeyDeleteCalls(stub func(context.Context, db.ExecSSHKeyDeleteParams) error) {
	fake.execSSHKeyDeleteMutex.Lock()
	defer fake.execSSHKeyDeleteMutex.Unlock()
	fake.ExecSSHKeyDeleteStub = stub
}

func (fake *FakeQuerier) ExecSSHKeyDeleteArgsForCall(i int) (context.Context, db.ExecSSHKeyDeleteParams) {
	fake.execSSHKeyDeleteMutex.RLock()
	defer fake.execSSHKeyDeleteMutex.RUnlock()
	argsForCall := fake.execSSHKeyDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSSHKeyDeleteReturns(result1 error) {
	fake.execSSHKeyDeleteMutex.Lock()
	defer fake.execSSHKeyDeleteMutex.Unlock()
	fake.ExecSSHKeyDeleteStub = nil
	fake.execSSHKeyDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSSHKeyDeleteReturnsOnCall(i int, result1 error) {
	fake.execSSHKeyDeleteMutex.Lock()
	defer fake.execSSHKeyDeleteMutex.Unlock()
	fake.ExecSSHKeyDeleteStub = nil
	if fake.execSSHKeyDeleteReturnsOnCall == nil {
		fake.execSSHKeyDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execSSHKeyDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSSHKeyGet(arg1 context.Context, arg2 db.ExecSSHKeyGetParams) (db.UnweaveExecSshKey, error) {
	fake.execSSHKeyGetMutex.Lock()
	ret, specificReturn := fake.execSSHKeyGetReturnsOnCall[len(fake.execSSHKeyGetArgsForCall)]
	fake.execSSHKeyGetArgsForCall = append(fake.execSSHKeyGetArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyGetParams
	}{arg1, arg2})
	stub := fake.ExecSSHKeyGetStub
	fakeReturns := fake.execSSHKeyGetReturns
	fake.recordInvocation("ExecSSHKeyGet", []interface{}{arg1, arg2})
	fake.execSSHKeyGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecSSHKeyGetCallCount() int {
	fake.execSSHKeyGetMutex.RLock()
	defer fake.execSSHKeyGetMutex.RUnlock()
	return len(fake.execSSHKeyGetArgsForCall)
}

func (fake *FakeQuerier) ExecSSHKeyGetCalls(stub func(context.Context, db.ExecSSHKeyGetParams) (db.UnweaveExecSshKey, error)) {
	fake.execSSHKeyGetMutex.Lock()
	defer fake.execSSHKeyGetMutex.Unlock()
	fake.ExecSSHKeyGetStub = stub
}

func (fake *FakeQuerier) ExecSSHKeyGetArgsForCall(i int) (context.Context, db.ExecSSHKeyGetParams) {
	fake.execSSHKeyGetMutex.RLock()
	defer fake.execSSHKeyGetMutex.RUnlock()
	argsForCall := fake.execSSHKeyGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSSHKeyGetReturns(result1 db.UnweaveExecSshKey, result2 error) {
	fake.execSSHKeyGetMutex.Lock()
	defer fake.execSSHKeyGetMutex.Unlock()
	fake.ExecSSHKeyGetStub = nil
	fake.execSSHKeyGetReturns = struct {
		result1 db.UnweaveExecSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecSSHKeyGetReturnsOnCall(i int, result1 db.UnweaveExecSshKey, result2 error) {
	fake.execSSHKeyGetMutex.Lock()
	defer fake.execSSHKeyGetMutex.Unlock()
	fake.ExecSSHKeyGetStub = nil
	if fake.execSSHKeyGetReturnsOnCall == nil {
		fake.execSSHKeyGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveExecSshKey
			result2 error
		})
	}
	fake.execSSHKeyGetReturnsOnCall[i] = struct {
		result1 db.UnweaveExecSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecSSHKeyInsert(arg1 context.Context, arg2 db.ExecSSHKeyInsertParams) error {
	fake.execSSHKeyInsertMutex.Lock()
	ret, specificReturn := fake.execSSHKeyInsertReturnsOnCall[len(fake.execSSHKeyInsertArgsForCall)]
	fake.execSSHKeyInsertArgsForCall = append(fake.execSSHKeyInsertArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecSSHKeyInsertParams
	}{arg1, arg2})
	stub := fake.ExecSSHKeyInsertStub
	fakeReturns := fake.execSSHKeyInsertReturns
	fake.recordInvocation("ExecSSHKeyInsert", []interface{}{arg1, arg2})
	fake.execSSHKeyInsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecSSHKeyInsertCallCount() int {
	fake.execSSHKeyInsertMutex.RLock()
	defer fake.execSSHKeyInsertMutex.RUnlock()
	return len(fake.execSSHKeyInsertArgsForCall)
}

func (fake *FakeQuerier) ExecSSHKeyInsertCalls(stub func(context.Context, db.ExecSSHKeyInsertParams) error) {
	fake.execSSHKeyInsertMutex.Lock()
	defer fake.execSSHKeyInsertMutex.Unlock()
	fake.ExecSSHKeyInsertStub = stub
}

func (fake *FakeQuerier) ExecSSHKeyInsertArgsForCall(i int) (context.Context, db.ExecSSHKeyInsertParams) {
	fake.execSSHKeyInsertMutex.RLock()
	defer fake.execSSHKeyInsertMutex.RUnlock()
	argsForCall := fake.execSSHKeyInsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSSHKeyInsertReturns(result1 error) {
	fake.execSSHKeyInsertMutex.Lock()
	defer fake.execSSHKeyInsertMutex.Unlock()
	fake.ExecSSHKeyInsertStub = nil
	fake.execSSHKeyInsertReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSSHKeyInsertReturnsOnCall(i int, result1 error) {
	fake.execSSHKeyInsertMutex.Lock()
	defer fake.execSSHKeyInsertMutex.Unlock()
	fake.ExecSSHKeyInsertStub = nil
	if fake.execSSHKeyInsertReturnsOnCall == nil {
		fake.execSSHKeyInsertReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execSSHKeyInsertReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecID(arg1 context.Context, arg2 string) ([]db.UnweaveExecSshKey, error) {
	fake.execSSHKeysGetByExecIDMutex.Lock()
	ret, specificReturn := fake.execSSHKeysGetByExecIDReturnsOnCall[len(fake.execSSHKeysGetByExecIDArgsForCall)]
	fake.execSSHKeysGetByExecIDArgsForCall = append(fake.execSSHKeysGetByExecIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecSSHKeysGetByExecIDStub
	fakeReturns := fake.execSSHKeysGetByExecIDReturns
	fake.recordInvocation("ExecSSHKeysGetByExecID", []interface{}{arg1, arg2})
	fake.execSSHKeysGetByExecIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecIDCallCount() int {
	fake.execSSHKeysGetByExecIDMutex.RLock()
	defer fake.execSSHKeysGetByExecIDMutex.RUnlock()
	return len(fake.execSSHKeysGetByExecIDArgsForCall)
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecIDCalls(stub func(context.Context, string) ([]db.UnweaveExecSshKey, error)) {
	fake.execSSHKeysGetByExecIDMutex.Lock()
	defer fake.execSSHKeysGetByExecIDMutex.Unlock()
	fake.ExecSSHKeysGetByExecIDStub = stub
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecIDArgsForCall(i int) (context.Context, string) {
	fake.execSSHKeysGetByExecIDMutex.RLock()
	defer fake.execSSHKeysGetByExecIDMutex.RUnlock()
	argsForCall := fake.execSSHKeysGetByExecIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecIDReturns(result1 []db.UnweaveExecSshKey, result2 error) {
	fake.execSSHKeysGetByExecIDMutex.Lock()
	defer fake.execSSHKeysGetByExecIDMutex.Unlock()
	fake.ExecSSHKeysGetByExecIDStub = nil
	fake.execSSHKeysGetByExecIDReturns = struct {
		result1 []db.UnweaveExecSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecSSHKeysGetByExecIDReturnsOnCall(i int, result1 []db.UnweaveExecSshKey, result2 error) {
	fake.execSSHKeysGetByExecIDMutex.Lock()
	defer fake.execSSHKeysGetByExecIDMutex.Unlock()
	fake.ExecSSHKeysGetByExecIDStub = nil
	if fake.execSSHKeysGetByExecIDReturnsOnCall == nil {
		fake.execSSHKeysGetByExecIDReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExecSshKey
			result2 error
		})
	}
	fake.execSSHKeysGetByExecIDReturnsOnCall[i] = struct {
		result1 []db.UnweaveExecSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecSetError(arg1 context.Context, arg2 db.ExecSetErrorParams) error {
	fake.execSetErrorMutex.Lock()
	ret, specificReturn := fake.execSetErrorReturnsOnCall[len(fake.execSetErrorArgsForCall)]
	fake.execSetErrorArgsForCall = append(fake.execSetErrorArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecSetErrorParams
	}{arg1, arg2})
	stub := fake.ExecSetErrorStub
	fakeReturns := fake.execSetErrorReturns
	fake.recordInvocation("ExecSetError", []interface{}{arg1, arg2})
	fake.execSetErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecSetErrorCallCount() int {
	fake.execSetErrorMutex.RLock()
	defer fake.execSetErrorMutex.RUnlock()
	return len(fake.execSetErrorArgsForCall)
}

func (fake *FakeQuerier) ExecSetErrorCalls(stub func(context.Context, db.ExecSetErrorParams) error) {
	fake.execSetErrorMutex.Lock()
	defer fake.execSetErrorMutex.Unlock()
	fake.ExecSetErrorStub = stub
}

func (fake *FakeQuerier) ExecSetErrorArgsForCall(i int) (context.Context, db.ExecSetErrorParams) {
	fake.execSetErrorMutex.RLock()
	defer fake.execSetErrorMutex.RUnlock()
	argsForCall := fake.execSetErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSetErrorReturns(result1 error) {
	fake.execSetErrorMutex.Lock()
	defer fake.execSetErrorMutex.Unlock()
	fake.ExecSetErrorStub = nil
	fake.execSetErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSetErrorReturnsOnCall(i int, result1 error) {
	fake.execSetErrorMutex.Lock()
	defer fake.execSetErrorMutex.Unlock()
	fake.ExecSetErrorStub = nil
	if fake.execSetErrorReturnsOnCall == nil {
		fake.execSetErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execSetErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSetFailed(arg1 context.Context, arg2 db.ExecSetFailedParams) error {
	fake.execSetFailedMutex.Lock()
	ret, specificReturn := fake.execSetFailedReturnsOnCall[len(fake.execSetFailedArgsForCall)]
	fake.execSetFailedArgsForCall = append(fake.execSetFailedArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecSetFailedParams
	}{arg1, arg2})
	stub := fake.ExecSetFailedStub
	fakeReturns := fake.execSetFailedReturns
	fake.recordInvocation("ExecSetFailed", []interface{}{arg1, arg2})
	fake.execSetFailedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecSetFailedCallCount() int {
	fake.execSetFailedMutex.RLock()
	defer fake.execSetFailedMutex.RUnlock()
	return len(fake.execSetFailedArgsForCall)
}

func (fake *FakeQuerier) ExecSetFailedCalls(stub func(context.Context, db.ExecSetFailedParams) error) {
	fake.execSetFailedMutex.Lock()
	defer fake.execSetFailedMutex.Unlock()
	fake.ExecSetFailedStub = stub
}

func (fake *FakeQuerier) ExecSetFailedArgsForCall(i int) (context.Context, db.ExecSetFailedParams) {
	fake.execSetFailedMutex.RLock()
	defer fake.execSetFailedMutex.RUnlock()
	argsForCall := fake.execSetFailedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecSetFailedReturns(result1 error) {
	fake.execSetFailedMutex.Lock()
	defer fake.execSetFailedMutex.Unlock()
	fake.ExecSetFailedStub = nil
	fake.execSetFailedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecSetFailedReturnsOnCall(i int, result1 error) {
	fake.execSetFailedMutex.Lock()
	defer fake.execSetFailedMutex.Unlock()
	fake.ExecSetFailedStub = nil
	if fake.execSetFailedReturnsOnCall == nil {
		fake.execSetFailedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execSetFailedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecStatusUpdate(arg1 context.Context, arg2 db.ExecStatusUpdateParams) error {
	fake.execStatusUpdateMutex.Lock()
	ret, specificReturn := fake.execStatusUpdateReturnsOnCall[len(fake.execStatusUpdateArgsForCall)]
	fake.execStatusUpdateArgsForCall = append(fake.execStatusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecStatusUpdateParams
	}{arg1, arg2})
	stub := fake.ExecStatusUpdateStub
	fakeReturns := fake.execStatusUpdateReturns
	fake.recordInvocation("ExecStatusUpdate", []interface{}{arg1, arg2})
	fake.execStatusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecStatusUpdateCallCount() int {
	fake.execStatusUpdateMutex.RLock()
	defer fake.execStatusUpdateMutex.RUnlock()
	return len(fake.execStatusUpdateArgsForCall)
}

func (fake *FakeQuerier) ExecStatusUpdateCalls(stub func(context.Context, db.ExecStatusUpdateParams) error) {
	fake.execStatusUpdateMutex.Lock()
	defer fake.execStatusUpdateMutex.Unlock()
	fake.ExecStatusUpdateStub = stub
}

func (fake *FakeQuerier) ExecStatusUpdateArgsForCall(i int) (context.Context, db.ExecStatusUpdateParams) {
	fake.execStatusUpdateMutex.RLock()
	defer fake.execStatusUpdateMutex.RUnlock()
	argsForCall := fake.execStatusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecStatusUpdateReturns(result1 error) {
	fake.execStatusUpdateMutex.Lock()
	defer fake.execStatusUpdateMutex.Unlock()
	fake.ExecStatusUpdateStub = nil
	fake.execStatusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecStatusUpdateReturnsOnCall(i int, result1 error) {
	fake.execStatusUpdateMutex.Lock()
	defer fake.execStatusUpdateMutex.Unlock()
	fake.ExecStatusUpdateStub = nil
	if fake.execStatusUpdateReturnsOnCall == nil {
		fake.execStatusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execStatusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateConnectionInfo(arg1 context.Context, arg2 db.ExecUpdateConnectionInfoParams) error {
	fake.execUpdateConnectionInfoMutex.Lock()
	ret, specificReturn := fake.execUpdateConnectionInfoReturnsOnCall[len(fake.execUpdateConnectionInfoArgsForCall)]
	fake.execUpdateConnectionInfoArgsForCall = append(fake.execUpdateConnectionInfoArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecUpdateConnectionInfoParams
	}{arg1, arg2})
	stub := fake.ExecUpdateConnectionInfoStub
	fakeReturns := fake.execUpdateConnectionInfoReturns
	fake.recordInvocation("ExecUpdateConnectionInfo", []interface{}{arg1, arg2})
	fake.execUpdateConnectionInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecUpdateConnectionInfoCallCount() int {
	fake.execUpdateConnectionInfoMutex.RLock()
	defer fake.execUpdateConnectionInfoMutex.RUnlock()
	return len(fake.execUpdateConnectionInfoArgsForCall)
}

func (fake *FakeQuerier) ExecUpdateConnectionInfoCalls(stub func(context.Context, db.ExecUpdateConnectionInfoParams) error) {
	fake.execUpdateConnectionInfoMutex.Lock()
	defer fake.execUpdateConnectionInfoMutex.Unlock()
	fake.ExecUpdateConnectionInfoStub = stub
}

func (fake *FakeQuerier) ExecUpdateConnectionInfoArgsForCall(i int) (context.Context, db.ExecUpdateConnectionInfoParams) {
	fake.execUpdateConnectionInfoMutex.RLock()
	defer fake.execUpdateConnectionInfoMutex.RUnlock()
	argsForCall := fake.execUpdateConnectionInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecUpdateConnectionInfoReturns(result1 error) {
	fake.execUpdateConnectionInfoMutex.Lock()
	defer fake.execUpdateConnectionInfoMutex.Unlock()
	fake.ExecUpdateConnectionInfoStub = nil
	fake.execUpdateConnectionInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateConnectionInfoReturnsOnCall(i int, result1 error) {
	fake.execUpdateConnectionInfoMutex.Lock()
	defer fake.execUpdateConnectionInfoMutex.Unlock()
	fake.ExecUpdateConnectionInfoStub = nil
	if fake.execUpdateConnectionInfoReturnsOnCall == nil {
		fake.execUpdateConnectionInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpdateConnectionInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateNetwork(arg1 context.Context, arg2 db.ExecUpdateNetworkParams) error {
	fake.execUpdateNetworkMutex.Lock()
	ret, specificReturn := fake.execUpdateNetworkReturnsOnCall[len(fake.execUpdateNetworkArgsForCall)]
	fake.execUpdateNetworkArgsForCall = append(fake.execUpdateNetworkArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecUpdateNetworkParams
	}{arg1, arg2})
	stub := fake.ExecUpdateNetworkStub
	fakeReturns := fake.execUpdateNetworkReturns
	fake.recordInvocation("ExecUpdateNetwork", []interface{}{arg1, arg2})
	fake.execUpdateNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecUpdateNetworkCallCount() int {
	fake.execUpdateNetworkMutex.RLock()
	defer fake.execUpdateNetworkMutex.RUnlock()
	return len(fake.execUpdateNetworkArgsForCall)
}

func (fake *FakeQuerier) ExecUpdateNetworkCalls(stub func(context.Context, db.ExecUpdateNetworkParams) error) {
	fake.execUpdateNetworkMutex.Lock()
	defer fake.execUpdateNetworkMutex.Unlock()
	fake.ExecUpdateNetworkStub = stub
}

func (fake *FakeQuerier) ExecUpdateNetworkArgsForCall(i int) (context.Context, db.ExecUpdateNetworkParams) {
	fake.execUpdateNetworkMutex.RLock()
	defer fake.execUpdateNetworkMutex.RUnlock()
	argsForCall := fake.execUpdateNetworkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecUpdateNetworkReturns(result1 error) {
	fake.execUpdateNetworkMutex.Lock()
	defer fake.execUpdateNetworkMutex.Unlock()
	fake.ExecUpdateNetworkStub = nil
	fake.execUpdateNetworkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateNetworkReturnsOnCall(i int, result1 error) {
	fake.execUpdateNetworkMutex.Lock()
	defer fake.execUpdateNetworkMutex.Unlock()
	fake.ExecUpdateNetworkStub = nil
	if fake.execUpdateNetworkReturnsOnCall == nil {
		fake.execUpdateNetworkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpdateNetworkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecVolumeCreate(arg1 context.Context, arg2 db.ExecVolumeCreateParams) error {
	fake.execVolumeCreateMutex.Lock()
	ret, specificReturn := fake.execVolumeCreateReturnsOnCall[len(fake.execVolumeCreateArgsForCall)]
	fake.execVolumeCreateArgsForCall = append(fake.execVolumeCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.ExecVolumeCreateParams
	}{arg1, arg2})
	stub := fake.ExecVolumeCreateStub
	fakeReturns := fake.execVolumeCreateReturns
	fake.recordInvocation("ExecVolumeCreate", []interface{}{arg1, arg2})
	fake.execVolumeCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecVolumeCreateCallCount() int {
	fake.execVolumeCreateMutex.RLock()
	defer fake.execVolumeCreateMutex.RUnlock()
	return len(fake.execVolumeCreateArgsForCall)
}

func (fake *FakeQuerier) ExecVolumeCreateCalls(stub func(context.Context, db.ExecVolumeCreateParams) error) {
	fake.execVolumeCreateMutex.Lock()
	defer fake.execVolumeCreateMutex.Unlock()
	fake.ExecVolumeCreateStub = stub
}

func (fake *FakeQuerier) ExecVolumeCreateArgsForCall(i int) (context.Context, db.ExecVolumeCreateParams) {
	fake.execVolumeCreateMutex.RLock()
	defer fake.execVolumeCreateMutex.RUnlock()
	argsForCall := fake.execVolumeCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecVolumeCreateReturns(result1 error) {
	fake.execVolumeCreateMutex.Lock()
	defer fake.execVolumeCreateMutex.Unlock()
	fake.ExecVolumeCreateStub = nil
	fake.execVolumeCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecVolumeCreateReturnsOnCall(i int, result1 error) {
	fake.execVolumeCreateMutex.Lock()
	defer fake.execVolumeCreateMutex.Unlock()
	fake.ExecVolumeCreateStub = nil
	if fake.execVolumeCreateReturnsOnCall == nil {
		fake.execVolumeCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execVolumeCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecVolumeDelete(arg1 context.Context, arg2 string) error {
	fake.execVolumeDeleteMutex.Lock()
	ret, specificReturn := fake.execVolumeDeleteReturnsOnCall[len(fake.execVolumeDeleteArgsForCall)]
	fake.execVolumeDeleteArgsForCall = append(fake.execVolumeDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecVolumeDeleteStub
	fakeReturns := fake.execVolumeDeleteReturns
	fake.recordInvocation("ExecVolumeDelete", []interface{}{arg1, arg2})
	fake.execVolumeDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecVolumeDeleteCallCount() int {
	fake.execVolumeDeleteMutex.RLock()
	defer fake.execVolumeDeleteMutex.RUnlock()
	return len(fake.execVolumeDeleteArgsForCall)
}

func (fake *FakeQuerier) ExecVolumeDeleteCalls(stub func(context.Context, string) error) {
	fake.execVolumeDeleteMutex.Lock()
	defer fake.execVolumeDeleteMutex.Unlock()
	fake.ExecVolumeDeleteStub = stub
}

func (fake *FakeQuerier) ExecVolumeDeleteArgsForCall(i int) (context.Context, string) {
	fake.execVolumeDeleteMutex.RLock()
	defer fake.execVolumeDeleteMutex.RUnlock()
	argsForCall := fake.execVolumeDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecVolumeDeleteReturns(result1 error) {
	fake.execVolumeDeleteMutex.Lock()
	defer fake.execVolumeDeleteMutex.Unlock()
	fake.ExecVolumeDeleteStub = nil
	fake.execVolumeDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecVolumeDeleteReturnsOnCall(i int, result1 error) {
	fake.execVolumeDeleteMutex.Lock()
	defer fake.execVolumeDeleteMutex.Unlock()
	fake.ExecVolumeDeleteStub = nil
	if fake.execVolumeDeleteReturnsOnCall == nil {
		fake.execVolumeDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execVolumeDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecVolumeGet(arg1 context.Context, arg2 string) ([]db.UnweaveExecVolume, error) {
	fake.execVolumeGetMutex.Lock()
	ret, specificReturn := fake.execVolumeGetReturnsOnCall[len(fake.execVolumeGetArgsForCall)]
	fake.execVolumeGetArgsForCall = append(fake.execVolumeGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExecVolumeGetStub
	fakeReturns := fake.execVolumeGetReturns
	fake.recordInvocation("ExecVolumeGet", []interface{}{arg1, arg2})
	fake.execVolumeGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ExecVolumeGetCallCount() int {
	fake.execVolumeGetMutex.RLock()
	defer fake.execVolumeGetMutex.RUnlock()
	return len(fake.execVolumeGetArgsForCall)
}

func (fake *FakeQuerier) ExecVolumeGetCalls(stub func(context.Context, string) ([]db.UnweaveExecVolume, error)) {
	fake.execVolumeGetMutex.Lock()
	defer fake.execVolumeGetMutex.Unlock()
	fake.ExecVolumeGetStub = stub
}

func (fake *FakeQuerier) ExecVolumeGetArgsForCall(i int) (context.Context, string) {
	fake.execVolumeGetMutex.RLock()
	defer fake.execVolumeGetMutex.RUnlock()
	argsForCall := fake.execVolumeGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecVolumeGetReturns(result1 []db.UnweaveExecVolume, result2 error) {
	fake.execVolumeGetMutex.Lock()
	defer fake.execVolumeGetMutex.Unlock()
	fake.ExecVolumeGetStub = nil
	fake.execVolumeGetReturns = struct {
		result1 []db.UnweaveExecVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecVolumeGetReturnsOnCall(i int, result1 []db.UnweaveExecVolume, result2 error) {
	fake.execVolumeGetMutex.Lock()
	defer fake.execVolumeGetMutex.Unlock()
	fake.ExecVolumeGetStub = nil
	if fake.execVolumeGetReturnsOnCall == nil {
		fake.execVolumeGetReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveExecVolume
			result2 error
		})
	}
	fake.execVolumeGetReturnsOnCall[i] = struct {
		result1 []db.UnweaveExecVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) MxExecGet(arg1 context.Context, arg2 string) (db.MxExecGetRow, error) {
	fake.mxExecGetMutex.Lock()
	ret, specificReturn := fake.mxExecGetReturnsOnCall[len(fake.mxExecGetArgsForCall)]
	fake.mxExecGetArgsForCall = append(fake.mxExecGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.MxExecGetStub
	fakeReturns := fake.mxExecGetReturns
	fake.recordInvocation("MxExecGet", []interface{}{arg1, arg2})
	fake.mxExecGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) MxExecGetCallCount() int {
	fake.mxExecGetMutex.RLock()
	defer fake.mxExecGetMutex.RUnlock()
	return len(fake.mxExecGetArgsForCall)
}

func (fake *FakeQuerier) MxExecGetCalls(stub func(context.Context, string) (db.MxExecGetRow, error)) {
	fake.mxExecGetMutex.Lock()
	defer fake.mxExecGetMutex.Unlock()
	fake.MxExecGetStub = stub
}

func (fake *FakeQuerier) MxExecGetArgsForCall(i int) (context.Context, string) {
	fake.mxExecGetMutex.RLock()
	defer fake.mxExecGetMutex.RUnlock()
	argsForCall := fake.mxExecGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) MxExecGetReturns(result1 db.MxExecGetRow, result2 error) {
	fake.mxExecGetMutex.Lock()
	defer fake.mxExecGetMutex.Unlock()
	fake.MxExecGetStub = nil
	fake.mxExecGetReturns = struct {
		result1 db.MxExecGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) MxExecGetReturnsOnCall(i int, result1 db.MxExecGetRow, result2 error) {
	fake.mxExecGetMutex.Lock()
	defer fake.mxExecGetMutex.Unlock()
	fake.MxExecGetStub = nil
	if fake.mxExecGetReturnsOnCall == nil {
		fake.mxExecGetReturnsOnCall = make(map[int]struct {
			result1 db.MxExecGetRow
			result2 error
		})
	}
	fake.mxExecGetReturnsOnCall[i] = struct {
		result1 db.MxExecGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) MxExecsGet(arg1 context.Context, arg2 string) ([]db.MxExecsGetRow, error) {
	fake.mxExecsGetMutex.Lock()
	ret, specificReturn := fake.mxExecsGetReturnsOnCall[len(fake.mxExecsGetArgsForCall)]
	fake.mxExecsGetArgsForCall = append(fake.mxExecsGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.MxExecsGetStub
	fakeReturns := fake.mxExecsGetReturns
	fake.recordInvocation("MxExecsGet", []interface{}{arg1, arg2})
	fake.mxExecsGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) MxExecsGetCallCount() int {
	fake.mxExecsGetMutex.RLock()
	defer fake.mxExecsGetMutex.RUnlock()
	return len(fake.mxExecsGetArgsForCall)
}

func (fake *FakeQuerier) MxExecsGetCalls(stub func(context.Context, string) ([]db.MxExecsGetRow, error)) {
	fake.mxExecsGetMutex.Lock()
	defer fake.mxExecsGetMutex.Unlock()
	fake.MxExecsGetStub = stub
}

func (fake *FakeQuerier) MxExecsGetArgsForCall(i int) (context.Context, string) {
	fake.mxExecsGetMutex.RLock()
	defer fake.mxExecsGetMutex.RUnlock()
	argsForCall := fake.mxExecsGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) MxExecsGetReturns(result1 []db.MxExecsGetRow, result2 error) {
	fake.mxExecsGetMutex.Lock()
	defer fake.mxExecsGetMutex.Unlock()
	fake.MxExecsGetStub = nil
	fake.mxExecsGetReturns = struct {
		result1 []db.MxExecsGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) MxExecsGetReturnsOnCall(i int, result1 []db.MxExecsGetRow, result2 error) {
	fake.mxExecsGetMutex.Lock()
	defer fake.mxExecsGetMutex.Unlock()
	fake.MxExecsGetStub = nil
	if fake.mxExecsGetReturnsOnCall == nil {
		fake.mxExecsGetReturnsOnCall = make(map[int]struct {
			result1 []db.MxExecsGetRow
			result2 error
		})
	}
	fake.mxExecsGetReturnsOnCall[i] = struct {
		result1 []db.MxExecsGetRow
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) NodeCreate(arg1 context.Context, arg2 db.NodeCreateParams) error {
	fake.nodeCreateMutex.Lock()
	ret, specificReturn := fake.nodeCreateReturnsOnCall[len(fake.nodeCreateArgsForCall)]
	fake.nodeCreateArgsForCall = append(fake.nodeCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.NodeCreateParams
	}{arg1, arg2})
	stub := fake.NodeCreateStub
	fakeReturns := fake.nodeCreateReturns
	fake.recordInvocation("NodeCreate", []interface{}{arg1, arg2})
	fake.nodeCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) NodeCreateCallCount() int {
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	return len(fake.nodeCreateArgsForCall)
}

func (fake *FakeQuerier) NodeCreateCalls(stub func(context.Context, db.NodeCreateParams) error) {
	fake.nodeCreateMutex.Lock()
	defer fake.nodeCreateMutex.Unlock()
	fake.NodeCreateStub = stub
}

func (fake *FakeQuerier) NodeCreateArgsForCall(i int) (context.Context, db.NodeCreateParams) {
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	argsForCall := fake.nodeCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) NodeCreateReturns(result1 error) {
	fake.nodeCreateMutex.Lock()
	defer fake.nodeCreateMutex.Unlock()
	fake.NodeCreateStub = nil
	fake.nodeCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) NodeCreateReturnsOnCall(i int, result1 error) {
	fake.nodeCreateMutex.Lock()
	defer fake.nodeCreateMutex.Unlock()
	fake.NodeCreateStub = nil
	if fake.nodeCreateReturnsOnCall == nil {
		fake.nodeCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) NodeStatusUpdate(arg1 context.Context, arg2 db.NodeStatusUpdateParams) error {
	fake.nodeStatusUpdateMutex.Lock()
	ret, specificReturn := fake.nodeStatusUpdateReturnsOnCall[len(fake.nodeStatusUpdateArgsForCall)]
	fake.nodeStatusUpdateArgsForCall = append(fake.nodeStatusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 db.NodeStatusUpdateParams
	}{arg1, arg2})
	stub := fake.NodeStatusUpdateStub
	fakeReturns := fake.nodeStatusUpdateReturns
	fake.recordInvocation("NodeStatusUpdate", []interface{}{arg1, arg2})
	fake.nodeStatusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) NodeStatusUpdateCallCount() int {
	fake.nodeStatusUpdateMutex.RLock()
	defer fake.nodeStatusUpdateMutex.RUnlock()
	return len(fake.nodeStatusUpdateArgsForCall)
}

func (fake *FakeQuerier) NodeStatusUpdateCalls(stub func(context.Context, db.NodeStatusUpdateParams) error) {
	fake.nodeStatusUpdateMutex.Lock()
	defer fake.nodeStatusUpdateMutex.Unlock()
	fake.NodeStatusUpdateStub = stub
}

func (fake *FakeQuerier) NodeStatusUpdateArgsForCall(i int) (context.Context, db.NodeStatusUpdateParams) {
	fake.nodeStatusUpdateMutex.RLock()
	defer fake.nodeStatusUpdateMutex.RUnlock()
	argsForCall := fake.nodeStatusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) NodeStatusUpdateReturns(result1 error) {
	fake.nodeStatusUpdateMutex.Lock()
	defer fake.nodeStatusUpdateMutex.Unlock()
	fake.NodeStatusUpdateStub = nil
	fake.nodeStatusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) NodeStatusUpdateReturnsOnCall(i int, result1 error) {
	fake.nodeStatusUpdateMutex.Lock()
	defer fake.nodeStatusUpdateMutex.Unlock()
	fake.NodeStatusUpdateStub = nil
	if fake.nodeStatusUpdateReturnsOnCall == nil {
		fake.nodeStatusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeStatusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ProjectGet(arg1 context.Context, arg2 string) (db.UnweaveProject, error) {
	fake.projectGetMutex.Lock()
	ret, specificReturn := fake.projectGetReturnsOnCall[len(fake.projectGetArgsForCall)]
	fake.projectGetArgsForCall = append(fake.projectGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ProjectGetStub
	fakeReturns := fake.projectGetReturns
	fake.recordInvocation("ProjectGet", []interface{}{arg1, arg2})
	fake.projectGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ProjectGetCallCount() int {
	fake.projectGetMutex.RLock()
	defer fake.projectGetMutex.RUnlock()
	return len(fake.projectGetArgsForCall)
}

func (fake *FakeQuerier) ProjectGetCalls(stub func(context.Context, string) (db.UnweaveProject, error)) {
	fake.projectGetMutex.Lock()
	defer fake.projectGetMutex.Unlock()
	fake.ProjectGetStub = stub
}

func (fake *FakeQuerier) ProjectGetArgsForCall(i int) (context.Context, string) {
	fake.projectGetMutex.RLock()
	defer fake.projectGetMutex.RUnlock()
	argsForCall := fake.projectGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ProjectGetReturns(result1 db.UnweaveProject, result2 error) {
	fake.projectGetMutex.Lock()
	defer fake.projectGetMutex.Unlock()
	fake.ProjectGetStub = nil
	fake.projectGetReturns = struct {
		result1 db.UnweaveProject
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ProjectGetReturnsOnCall(i int, result1 db.UnweaveProject, result2 error) {
	fake.projectGetMutex.Lock()
	defer fake.projectGetMutex.Unlock()
	fake.ProjectGetStub = nil
	if fake.projectGetReturnsOnCall == nil {
		fake.projectGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveProject
			result2 error
		})
	}
	fake.projectGetReturnsOnCall[i] = struct {
		result1 db.UnweaveProject
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeyAdd(arg1 context.Context, arg2 db.SSHKeyAddParams) error {
	fake.sSHKeyAddMutex.Lock()
	ret, specificReturn := fake.sSHKeyAddReturnsOnCall[len(fake.sSHKeyAddArgsForCall)]
	fake.sSHKeyAddArgsForCall = append(fake.sSHKeyAddArgsForCall, struct {
		arg1 context.Context
		arg2 db.SSHKeyAddParams
	}{arg1, arg2})
	stub := fake.SSHKeyAddStub
	fakeReturns := fake.sSHKeyAddReturns
	fake.recordInvocation("SSHKeyAdd", []interface{}{arg1, arg2})
	fake.sSHKeyAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) SSHKeyAddCallCount() int {
	fake.sSHKeyAddMutex.RLock()
	defer fake.sSHKeyAddMutex.RUnlock()
	return len(fake.sSHKeyAddArgsForCall)
}

func (fake *FakeQuerier) SSHKeyAddCalls(stub func(context.Context, db.SSHKeyAddParams) error) {
	fake.sSHKeyAddMutex.Lock()
	defer fake.sSHKeyAddMutex.Unlock()
	fake.SSHKeyAddStub = stub
}

func (fake *FakeQuerier) SSHKeyAddArgsForCall(i int) (context.Context, db.SSHKeyAddParams) {
	fake.sSHKeyAddMutex.RLock()
	defer fake.sSHKeyAddMutex.RUnlock()
	argsForCall := fake.sSHKeyAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) SSHKeyAddReturns(result1 error) {
	fake.sSHKeyAddMutex.Lock()
	defer fake.sSHKeyAddMutex.Unlock()
	fake.SSHKeyAddStub = nil
	fake.sSHKeyAddReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) SSHKeyAddReturnsOnCall(i int, result1 error) {
	fake.sSHKeyAddMutex.Lock()
	defer fake.sSHKeyAddMutex.Unlock()
	fake.SSHKeyAddStub = nil
	if fake.sSHKeyAddReturnsOnCall == nil {
		fake.sSHKeyAddReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sSHKeyAddReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) SSHKeyGetByName(arg1 context.Context, arg2 db.SSHKeyGetByNameParams) (db.UnweaveSshKey, error) {
	fake.sSHKeyGetByNameMutex.Lock()
	ret, specificReturn := fake.sSHKeyGetByNameReturnsOnCall[len(fake.sSHKeyGetByNameArgsForCall)]
	fake.sSHKeyGetByNameArgsForCall = append(fake.sSHKeyGetByNameArgsForCall, struct {
		arg1 context.Context
		arg2 db.SSHKeyGetByNameParams
	}{arg1, arg2})
	stub := fake.SSHKeyGetByNameStub
	fakeReturns := fake.sSHKeyGetByNameReturns
	fake.recordInvocation("SSHKeyGetByName", []interface{}{arg1, arg2})
	fake.sSHKeyGetByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) SSHKeyGetByNameCallCount() int {
	fake.sSHKeyGetByNameMutex.RLock()
	defer fake.sSHKeyGetByNameMutex.RUnlock()
	return len(fake.sSHKeyGetByNameArgsForCall)
}

func (fake *FakeQuerier) SSHKeyGetByNameCalls(stub func(context.Context, db.SSHKeyGetByNameParams) (db.UnweaveSshKey, error)) {
	fake.sSHKeyGetByNameMutex.Lock()
	defer fake.sSHKeyGetByNameMutex.Unlock()
	fake.SSHKeyGetByNameStub = stub
}

func (fake *FakeQuerier) SSHKeyGetByNameArgsForCall(i int) (context.Context, db.SSHKeyGetByNameParams) {
	fake.sSHKeyGetByNameMutex.RLock()
	defer fake.sSHKeyGetByNameMutex.RUnlock()
	argsForCall := fake.sSHKeyGetByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) SSHKeyGetByNameReturns(result1 db.UnweaveSshKey, result2 error) {
	fake.sSHKeyGetByNameMutex.Lock()
	defer fake.sSHKeyGetByNameMutex.Unlock()
	fake.SSHKeyGetByNameStub = nil
	fake.sSHKeyGetByNameReturns = struct {
		result1 db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeyGetByNameReturnsOnCall(i int, result1 db.UnweaveSshKey, result2 error) {
	fake.sSHKeyGetByNameMutex.Lock()
	defer fake.sSHKeyGetByNameMutex.Unlock()
	fake.SSHKeyGetByNameStub = nil
	if fake.sSHKeyGetByNameReturnsOnCall == nil {
		fake.sSHKeyGetByNameReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveSshKey
			result2 error
		})
	}
	fake.sSHKeyGetByNameReturnsOnCall[i] = struct {
		result1 db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeyGetByPublicKey(arg1 context.Context, arg2 db.SSHKeyGetByPublicKeyParams) (db.UnweaveSshKey, error) {
	fake.sSHKeyGetByPublicKeyMutex.Lock()
	ret, specificReturn := fake.sSHKeyGetByPublicKeyReturnsOnCall[len(fake.sSHKeyGetByPublicKeyArgsForCall)]
	fake.sSHKeyGetByPublicKeyArgsForCall = append(fake.sSHKeyGetByPublicKeyArgsForCall, struct {
		arg1 context.Context
		arg2 db.SSHKeyGetByPublicKeyParams
	}{arg1, arg2})
	stub := fake.SSHKeyGetByPublicKeyStub
	fakeReturns := fake.sSHKeyGetByPublicKeyReturns
	fake.recordInvocation("SSHKeyGetByPublicKey", []interface{}{arg1, arg2})
	fake.sSHKeyGetByPublicKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) SSHKeyGetByPublicKeyCallCount() int {
	fake.sSHKeyGetByPublicKeyMutex.RLock()
	defer fake.sSHKeyGetByPublicKeyMutex.RUnlock()
	return len(fake.sSHKeyGetByPublicKeyArgsForCall)
}

func (fake *FakeQuerier) SSHKeyGetByPublicKeyCalls(stub func(context.Context, db.SSHKeyGetByPublicKeyParams) (db.UnweaveSshKey, error)) {
	fake.sSHKeyGetByPublicKeyMutex.Lock()
	defer fake.sSHKeyGetByPublicKeyMutex.Unlock()
	fake.SSHKeyGetByPublicKeyStub = stub
}

func (fake *FakeQuerier) SSHKeyGetByPublicKeyArgsForCall(i int) (context.Context, db.SSHKeyGetByPublicKeyParams) {
	fake.sSHKeyGetByPublicKeyMutex.RLock()
	defer fake.sSHKeyGetByPublicKeyMutex.RUnlock()
	argsForCall := fake.sSHKeyGetByPublicKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) SSHKeyGetByPublicKeyReturns(result1 db.UnweaveSshKey, result2 error) {
	fake.sSHKeyGetByPublicKeyMutex.Lock()
	defer fake.sSHKeyGetByPublicKeyMutex.Unlock()
	fake.SSHKeyGetByPublicKeyStub = nil
	fake.sSHKeyGetByPublicKeyReturns = struct {
		result1 db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeyGetByPublicKeyReturnsOnCall(i int, result1 db.UnweaveSshKey, result2 error) {
	fake.sSHKeyGetByPublicKeyMutex.Lock()
	defer fake.sSHKeyGetByPublicKeyMutex.Unlock()
	fake.SSHKeyGetByPublicKeyStub = nil
	if fake.sSHKeyGetByPublicKeyReturnsOnCall == nil {
		fake.sSHKeyGetByPublicKeyReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveSshKey
			result2 error
		})
	}
	fake.sSHKeyGetByPublicKeyReturnsOnCall[i] = struct {
		result1 db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeysGet(arg1 context.Context, arg2 string) ([]db.UnweaveSshKey, error) {
	fake.sSHKeysGetMutex.Lock()
	ret, specificReturn := fake.sSHKeysGetReturnsOnCall[len(fake.sSHKeysGetArgsForCall)]
	fake.sSHKeysGetArgsForCall = append(fake.sSHKeysGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SSHKeysGetStub
	fakeReturns := fake.sSHKeysGetReturns
	fake.recordInvocation("SSHKeysGet", []interface{}{arg1, arg2})
	fake.sSHKeysGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) SSHKeysGetCallCount() int {
	fake.sSHKeysGetMutex.RLock()
	defer fake.sSHKeysGetMutex.RUnlock()
	return len(fake.sSHKeysGetArgsForCall)
}

func (fake *FakeQuerier) SSHKeysGetCalls(stub func(context.Context, string) ([]db.UnweaveSshKey, error)) {
	fake.sSHKeysGetMutex.Lock()
	defer fake.sSHKeysGetMutex.Unlock()
	fake.SSHKeysGetStub = stub
}

func (fake *FakeQuerier) SSHKeysGetArgsForCall(i int) (context.Context, string) {
	fake.sSHKeysGetMutex.RLock()
	defer fake.sSHKeysGetMutex.RUnlock()
	argsForCall := fake.sSHKeysGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) SSHKeysGetReturns(result1 []db.UnweaveSshKey, result2 error) {
	fake.sSHKeysGetMutex.Lock()
	defer fake.sSHKeysGetMutex.Unlock()
	fake.SSHKeysGetStub = nil
	fake.sSHKeysGetReturns = struct {
		result1 []db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeysGetReturnsOnCall(i int, result1 []db.UnweaveSshKey, result2 error) {
	fake.sSHKeysGetMutex.Lock()
	defer fake.sSHKeysGetMutex.Unlock()
	fake.SSHKeysGetStub = nil
	if fake.sSHKeysGetReturnsOnCall == nil {
		fake.sSHKeysGetReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveSshKey
			result2 error
		})
	}
	fake.sSHKeysGetReturnsOnCall[i] = struct {
		result1 []db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeysGetByIDs(arg1 context.Context, arg2 []string) ([]db.UnweaveSshKey, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sSHKeysGetByIDsMutex.Lock()
	ret, specificReturn := fake.sSHKeysGetByIDsReturnsOnCall[len(fake.sSHKeysGetByIDsArgsForCall)]
	fake.sSHKeysGetByIDsArgsForCall = append(fake.sSHKeysGetByIDsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.SSHKeysGetByIDsStub
	fakeReturns := fake.sSHKeysGetByIDsReturns
	fake.recordInvocation("SSHKeysGetByIDs", []interface{}{arg1, arg2Copy})
	fake.sSHKeysGetByIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) SSHKeysGetByIDsCallCount() int {
	fake.sSHKeysGetByIDsMutex.RLock()
	defer fake.sSHKeysGetByIDsMutex.RUnlock()
	return len(fake.sSHKeysGetByIDsArgsForCall)
}

func (fake *FakeQuerier) SSHKeysGetByIDsCalls(stub func(context.Context, []string) ([]db.UnweaveSshKey, error)) {
	fake.sSHKeysGetByIDsMutex.Lock()
	defer fake.sSHKeysGetByIDsMutex.Unlock()
	fake.SSHKeysGetByIDsStub = stub
}

func (fake *FakeQuerier) SSHKeysGetByIDsArgsForCall(i int) (context.Context, []string) {
	fake.sSHKeysGetByIDsMutex.RLock()
	defer fake.sSHKeysGetByIDsMutex.RUnlock()
	argsForCall := fake.sSHKeysGetByIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) SSHKeysGetByIDsReturns(result1 []db.UnweaveSshKey, result2 error) {
	fake.sSHKeysGetByIDsMutex.Lock()
	defer fake.sSHKeysGetByIDsMutex.Unlock()
	fake.SSHKeysGetByIDsStub = nil
	fake.sSHKeysGetByIDsReturns = struct {
		result1 []db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) SSHKeysGetByIDsReturnsOnCall(i int, result1 []db.UnweaveSshKey, result2 error) {
	fake.sSHKeysGetByIDsMutex.Lock()
	defer fake.sSHKeysGetByIDsMutex.Unlock()
	fake.SSHKeysGetByIDsStub = nil
	if fake.sSHKeysGetByIDsReturnsOnCall == nil {
		fake.sSHKeysGetByIDsReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveSshKey
			result2 error
		})
	}
	fake.sSHKeysGetByIDsReturnsOnCall[i] = struct {
		result1 []db.UnweaveSshKey
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeCreate(arg1 context.Context, arg2 db.VolumeCreateParams) (db.UnweaveVolume, error) {
	fake.volumeCreateMutex.Lock()
	ret, specificReturn := fake.volumeCreateReturnsOnCall[len(fake.volumeCreateArgsForCall)]
	fake.volumeCreateArgsForCall = append(fake.volumeCreateArgsForCall, struct {
		arg1 context.Context
		arg2 db.VolumeCreateParams
	}{arg1, arg2})
	stub := fake.VolumeCreateStub
	fakeReturns := fake.volumeCreateReturns
	fake.recordInvocation("VolumeCreate", []interface{}{arg1, arg2})
	fake.volumeCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) VolumeCreateCallCount() int {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	return len(fake.volumeCreateArgsForCall)
}

func (fake *FakeQuerier) VolumeCreateCalls(stub func(context.Context, db.VolumeCreateParams) (db.UnweaveVolume, error)) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = stub
}

func (fake *FakeQuerier) VolumeCreateArgsForCall(i int) (context.Context, db.VolumeCreateParams) {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	argsForCall := fake.volumeCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) VolumeCreateReturns(result1 db.UnweaveVolume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	fake.volumeCreateReturns = struct {
		result1 db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeCreateReturnsOnCall(i int, result1 db.UnweaveVolume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	if fake.volumeCreateReturnsOnCall == nil {
		fake.volumeCreateReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveVolume
			result2 error
		})
	}
	fake.volumeCreateReturnsOnCall[i] = struct {
		result1 db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeDelete(arg1 context.Context, arg2 string) error {
	fake.volumeDeleteMutex.Lock()
	ret, specificReturn := fake.volumeDeleteReturnsOnCall[len(fake.volumeDeleteArgsForCall)]
	fake.volumeDeleteArgsForCall = append(fake.volumeDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.VolumeDeleteStub
	fakeReturns := fake.volumeDeleteReturns
	fake.recordInvocation("VolumeDelete", []interface{}{arg1, arg2})
	fake.volumeDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) VolumeDeleteCallCount() int {
	fake.volumeDeleteMutex.RLock()
	defer fake.volumeDeleteMutex.RUnlock()
	return len(fake.volumeDeleteArgsForCall)
}

func (fake *FakeQuerier) VolumeDeleteCalls(stub func(context.Context, string) error) {
	fake.volumeDeleteMutex.Lock()
	defer fake.volumeDeleteMutex.Unlock()
	fake.VolumeDeleteStub = stub
}

func (fake *FakeQuerier) VolumeDeleteArgsForCall(i int) (context.Context, string) {
	fake.volumeDeleteMutex.RLock()
	defer fake.volumeDeleteMutex.RUnlock()
	argsForCall := fake.volumeDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) VolumeDeleteReturns(result1 error) {
	fake.volumeDeleteMutex.Lock()
	defer fake.volumeDeleteMutex.Unlock()
	fake.VolumeDeleteStub = nil
	fake.volumeDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) VolumeDeleteReturnsOnCall(i int, result1 error) {
	fake.volumeDeleteMutex.Lock()
	defer fake.volumeDeleteMutex.Unlock()
	fake.VolumeDeleteStub = nil
	if fake.volumeDeleteReturnsOnCall == nil {
		fake.volumeDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) VolumeGet(arg1 context.Context, arg2 db.VolumeGetParams) (db.UnweaveVolume, error) {
	fake.volumeGetMutex.Lock()
	ret, specificReturn := fake.volumeGetReturnsOnCall[len(fake.volumeGetArgsForCall)]
	fake.volumeGetArgsForCall = append(fake.volumeGetArgsForCall, struct {
		arg1 context.Context
		arg2 db.VolumeGetParams
	}{arg1, arg2})
	stub := fake.VolumeGetStub
	fakeReturns := fake.volumeGetReturns
	fake.recordInvocation("VolumeGet", []interface{}{arg1, arg2})
	fake.volumeGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) VolumeGetCallCount() int {
	fake.volumeGetMutex.RLock()
	defer fake.volumeGetMutex.RUnlock()
	return len(fake.volumeGetArgsForCall)
}

func (fake *FakeQuerier) VolumeGetCalls(stub func(context.Context, db.VolumeGetParams) (db.UnweaveVolume, error)) {
	fake.volumeGetMutex.Lock()
	defer fake.volumeGetMutex.Unlock()
	fake.VolumeGetStub = stub
}

func (fake *FakeQuerier) VolumeGetArgsForCall(i int) (context.Context, db.VolumeGetParams) {
	fake.volumeGetMutex.RLock()
	defer fake.volumeGetMutex.RUnlock()
	argsForCall := fake.volumeGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) VolumeGetReturns(result1 db.UnweaveVolume, result2 error) {
	fake.volumeGetMutex.Lock()
	defer fake.volumeGetMutex.Unlock()
	fake.VolumeGetStub = nil
	fake.volumeGetReturns = struct {
		result1 db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeGetReturnsOnCall(i int, result1 db.UnweaveVolume, result2 error) {
	fake.volumeGetMutex.Lock()
	defer fake.volumeGetMutex.Unlock()
	fake.VolumeGetStub = nil
	if fake.volumeGetReturnsOnCall == nil {
		fake.volumeGetReturnsOnCall = make(map[int]struct {
			result1 db.UnweaveVolume
			result2 error
		})
	}
	fake.volumeGetReturnsOnCall[i] = struct {
		result1 db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeList(arg1 context.Context, arg2 string) ([]db.UnweaveVolume, error) {
	fake.volumeListMutex.Lock()
	ret, specificReturn := fake.volumeListReturnsOnCall[len(fake.volumeListArgsForCall)]
	fake.volumeListArgsForCall = append(fake.volumeListArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.VolumeListStub
	fakeReturns := fake.volumeListReturns
	fake.recordInvocation("VolumeList", []interface{}{arg1, arg2})
	fake.volumeListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) VolumeListCallCount() int {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	return len(fake.volumeListArgsForCall)
}

func (fake *FakeQuerier) VolumeListCalls(stub func(context.Context, string) ([]db.UnweaveVolume, error)) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = stub
}

func (fake *FakeQuerier) VolumeListArgsForCall(i int) (context.Context, string) {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	argsForCall := fake.volumeListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) VolumeListReturns(result1 []db.UnweaveVolume, result2 error) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = nil
	fake.volumeListReturns = struct {
		result1 []db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeListReturnsOnCall(i int, result1 []db.UnweaveVolume, result2 error) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = nil
	if fake.volumeListReturnsOnCall == nil {
		fake.volumeListReturnsOnCall = make(map[int]struct {
			result1 []db.UnweaveVolume
			result2 error
		})
	}
	fake.volumeListReturnsOnCall[i] = struct {
		result1 []db.UnweaveVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) VolumeUpdate(arg1 context.Context, arg2 db.VolumeUpdateParams) error {
	fake.volumeUpdateMutex.Lock()
	ret, specificReturn := fake.volumeUpdateReturnsOnCall[len(fake.volumeUpdateArgsForCall)]
	fake.volumeUpdateArgsForCall = append(fake.volumeUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 db.VolumeUpdateParams
	}{arg1, arg2})
	stub := fake.VolumeUpdateStub
	fakeReturns := fake.volumeUpdateReturns
	fake.recordInvocation("VolumeUpdate", []interface{}{arg1, arg2})
	fake.volumeUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) VolumeUpdateCallCount() int {
	fake.volumeUpdateMutex.RLock()
	defer fake.volumeUpdateMutex.RUnlock()
	return len(fake.volumeUpdateArgsForCall)
}

func (fake *FakeQuerier) VolumeUpdateCalls(stub func(context.Context, db.VolumeUpdateParams) error) {
	fake.volumeUpdateMutex.Lock()
	defer fake.volumeUpdateMutex.Unlock()
	fake.VolumeUpdateStub = stub
}

func (fake *FakeQuerier) VolumeUpdateArgsForCall(i int) (context.Context, db.VolumeUpdateParams) {
	fake.volumeUpdateMutex.RLock()
	defer fake.volumeUpdateMutex.RUnlock()
	argsForCall := fake.volumeUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) VolumeUpdateReturns(result1 error) {
	fake.volumeUpdateMutex.Lock()
	defer fake.volumeUpdateMutex.Unlock()
	fake.VolumeUpdateStub = nil
	fake.volumeUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) VolumeUpdateReturnsOnCall(i int, result1 error) {
	fake.volumeUpdateMutex.Lock()
	defer fake.volumeUpdateMutex.Unlock()
	fake.VolumeUpdateStub = nil
	if fake.volumeUpdateReturnsOnCall == nil {
		fake.volumeUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildCreateMutex.RLock()
	defer fake.buildCreateMutex.RUnlock()
	fake.buildGetMutex.RLock()
	defer fake.buildGetMutex.RUnlock()
	fake.buildGetUsedByMutex.RLock()
	defer fake.buildGetUsedByMutex.RUnlock()
	fake.buildUpdateMutex.RLock()
	defer fake.buildUpdateMutex.RUnlock()
	fake.endpointCheckMutex.RLock()
	defer fake.endpointCheckMutex.RUnlock()
	fake.endpointCheckCreateMutex.RLock()
	defer fake.endpointCheckCreateMutex.RUnlock()
	fake.endpointCheckStepCreateMutex.RLock()
	defer fake.endpointCheckStepCreateMutex.RUnlock()
	fake.endpointCheckStepUpdateMutex.RLock()
	defer fake.endpointCheckStepUpdateMutex.RUnlock()
	fake.endpointCheckStepsMutex.RLock()
	defer fake.endpointCheckStepsMutex.RUnlock()
	fake.endpointCreateMutex.RLock()
	defer fake.endpointCreateMutex.RUnlock()
	fake.endpointDeleteMutex.RLock()
	defer fake.endpointDeleteMutex.RUnlock()
	fake.endpointEvalMutex.RLock()
	defer fake.endpointEvalMutex.RUnlock()
	fake.endpointEvalAttachMutex.RLock()
	defer fake.endpointEvalAttachMutex.RUnlock()
	fake.endpointGetMutex.RLock()
	defer fake.endpointGetMutex.RUnlock()
	fake.endpointVersionMutex.RLock()
	defer fake.endpointVersionMutex.RUnlock()
	fake.endpointVersionCreateMutex.RLock()
	defer fake.endpointVersionCreateMutex.RUnlock()
	fake.endpointVersionDemoteMutex.RLock()
	defer fake.endpointVersionDemoteMutex.RUnlock()
	fake.endpointVersionListMutex.RLock()
	defer fake.endpointVersionListMutex.RUnlock()
	fake.endpointVersionPromoteMutex.RLock()
	defer fake.endpointVersionPromoteMutex.RUnlock()
	fake.endpointsForProjectMutex.RLock()
	defer fake.endpointsForProjectMutex.RUnlock()
	fake.evalCreateMutex.RLock()
	defer fake.evalCreateMutex.RUnlock()
	fake.evalDeleteMutex.RLock()
	defer fake.evalDeleteMutex.RUnlock()
	fake.evalGetMutex.RLock()
	defer fake.evalGetMutex.RUnlock()
	fake.evalListMutex.RLock()
	defer fake.evalListMutex.RUnlock()
	fake.evalListForProjectMutex.RLock()
	defer fake.evalListForProjectMutex.RUnlock()
	fake.execCreateMutex.RLock()
	defer fake.execCreateMutex.RUnlock()
	fake.execGetMutex.RLock()
	defer fake.execGetMutex.RUnlock()
	fake.execGetAllActiveMutex.RLock()
	defer fake.execGetAllActiveMutex.RUnlock()
	fake.execListMutex.RLock()
	defer fake.execListMutex.RUnlock()
	fake.execListActiveByProviderMutex.RLock()
	defer fake.execListActiveByProviderMutex.RUnlock()
	fake.execListByProviderMutex.RLock()
	defer fake.execListByProviderMutex.RUnlock()
	fake.execSSHKeyDeleteMutex.RLock()
	defer fake.execSSHKeyDeleteMutex.RUnlock()
	fake.execSSHKeyGetMutex.RLock()
	defer fake.execSSHKeyGetMutex.RUnlock()
	fake.execSSHKeyInsertMutex.RLock()
	defer fake.execSSHKeyInsertMutex.RUnlock()
	fake.execSSHKeysGetByExecIDMutex.RLock()
	defer fake.execSSHKeysGetByExecIDMutex.RUnlock()
	fake.execSetErrorMutex.RLock()
	defer fake.execSetErrorMutex.RUnlock()
	fake.execSetFailedMutex.RLock()
	defer fake.execSetFailedMutex.RUnlock()
	fake.execStatusUpdateMutex.RLock()
	defer fake.execStatusUpdateMutex.RUnlock()
	fake.execUpdateConnectionInfoMutex.RLock()
	defer fake.execUpdateConnectionInfoMutex.RUnlock()
	fake.execUpdateNetworkMutex.RLock()
	defer fake.execUpdateNetworkMutex.RUnlock()
	fake.execVolumeCreateMutex.RLock()
	defer fake.execVolumeCreateMutex.RUnlock()
	fake.execVolumeDeleteMutex.RLock()
	defer fake.execVolumeDeleteMutex.RUnlock()
	fake.execVolumeGetMutex.RLock()
	defer fake.execVolumeGetMutex.RUnlock()
	fake.mxExecGetMutex.RLock()
	defer fake.mxExecGetMutex.RUnlock()
	fake.mxExecsGetMutex.RLock()
	defer fake.mxExecsGetMutex.RUnlock()
	fake.nodeCreateMutex.RLock()
	defer fake.nodeCreateMutex.RUnlock()
	fake.nodeStatusUpdateMutex.RLock()
	defer fake.nodeStatusUpdateMutex.RUnlock()
	fake.projectGetMutex.RLock()
	defer fake.projectGetMutex.RUnlock()
	fake.sSHKeyAddMutex.RLock()
	defer fake.sSHKeyAddMutex.RUnlock()
	fake.sSHKeyGetByNameMutex.RLock()
	defer fake.sSHKeyGetByNameMutex.RUnlock()
	fake.sSHKeyGetByPublicKeyMutex.RLock()
	defer fake.sSHKeyGetByPublicKeyMutex.RUnlock()
	fake.sSHKeysGetMutex.RLock()
	defer fake.sSHKeysGetMutex.RUnlock()
	fake.sSHKeysGetByIDsMutex.RLock()
	defer fake.sSHKeysGetByIDsMutex.RUnlock()
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	fake.volumeDeleteMutex.RLock()
	defer fake.volumeDeleteMutex.RUnlock()
	fake.volumeGetMutex.RLock()
	defer fake.volumeGetMutex.RUnlock()
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	fake.volumeUpdateMutex.RLock()
	defer fake.volumeUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQuerier) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Querier = new(FakeQuerier)
